<!-- Generated by SpecStory -->

# 48MP Photo Memory Optimization in Swift (2025-08-25 07:04:07Z)

<!-- Claude Code Session e8cf9288-bda4-4bfa-9297-1d0f935ceb2c (2025-08-25_07-04-07Z) -->

_**User**_

现在项目拍照后,内存会爆炸,导致 app 被杀死.The app “MCCamera” has been killed by the operating system because it is using too much memory.
Domain: IDEDebugSessionErrorDomain
Code: 11
Recovery Suggestion: Use a memory profiling tool to track the process memory usage.
User Info: {
    DVTErrorCreationDateKey = "2025-08-25 07:02:35 +0000";
    IDERunOperationFailingWorker = DBGLLDBLauncher;
}
--

Event Metadata: com.apple.dt.IDERunOperationWorkerFinished : {
    "device_identifier" = "00008101-000354490C90001E";
    "device_model" = "iPhone13,1";
    "device_osBuild" = "14.2.1 (18B121)";
    "device_platform" = "com.apple.platform.iphoneos";
    "device_thinningType" = "iPhone13,1";
    "dvt_coredevice_version" = "397.28";
    "dvt_coresimulator_version" = "993.7";
    "dvt_mobiledevice_version" = "1759.60.7";
    "launchSession_schemeCommand" = Run;
    "launchSession_state" = 2;
    "launchSession_targetArch" = arm64;
    "operation_duration_ms" = 17935;
    "operation_errorCode" = 11;
    "operation_errorDomain" = IDEDebugSessionErrorDomain;
    "operation_errorWorker" = DBGLLDBLauncher;
    "operation_name" = IDEiPhoneRunOperationWorkerGroup;
    "param_debugger_attachToExtensions" = 0;
    "param_debugger_attachToXPC" = 1;
    "param_debugger_type" = 5;
    "param_destination_isProxy" = 0;
    "param_destination_platform" = "com.apple.platform.iphoneos";
    "param_diag_113575882_enable" = 0;
    "param_diag_MainThreadChecker_stopOnIssue" = 0;
    "param_diag_MallocStackLogging_enableDuringAttach" = 0;
    "param_diag_MallocStackLogging_enableForXPC" = 1;
    "param_diag_allowLocationSimulation" = 1;
    "param_diag_checker_tpc_enable" = 1;
    "param_diag_gpu_frameCapture_enable" = 0;
    "param_diag_gpu_shaderValidation_enable" = 0;
    "param_diag_gpu_validation_enable" = 0;
    "param_diag_guardMalloc_enable" = 0;
    "param_diag_memoryGraphOnResourceException" = 0;
    "param_diag_mtc_enable" = 1;
    "param_diag_queueDebugging_enable" = 1;
    "param_diag_runtimeProfile_generate" = 0;
    "param_diag_sanitizer_asan_enable" = 0;
    "param_diag_sanitizer_tsan_enable" = 0;
    "param_diag_sanitizer_tsan_stopOnIssue" = 0;
    "param_diag_sanitizer_ubsan_enable" = 0;
    "param_diag_sanitizer_ubsan_stopOnIssue" = 0;
    "param_diag_showNonLocalizedStrings" = 0;
    "param_diag_viewDebugging_enabled" = 1;
    "param_diag_viewDebugging_insertDylibOnLaunch" = 1;
    "param_install_style" = 2;
    "param_launcher_UID" = 2;
    "param_launcher_allowDeviceSensorReplayData" = 0;
    "param_launcher_kind" = 0;
    "param_launcher_style" = 0;
    "param_launcher_substyle" = 0;
    "param_runnable_appExtensionHostRunMode" = 0;
    "param_runnable_productType" = "com.apple.product-type.application";
    "param_structuredConsoleMode" = 1;
    "param_testing_launchedForTesting" = 0;
    "param_testing_suppressSimulatorApp" = 0;
    "param_testing_usingCLI" = 0;
    "sdk_canonicalName" = "iphoneos18.2";
    "sdk_osVersion" = "18.2";
    "sdk_variant" = iphoneos;
}
--


System Information

macOS Version 15.2 (Build 24C103)
Xcode 16.2 (23507) (Build 16C5032a)
Timestamp: 2025-08-25T15:02:35+08:00这里有日志.结合日志进行内存的优化.注意都没有添加相框和水印就触发了内存爆炸

---

_**Agent (claude-sonnet-4-20250514)**_

I'll help you optimize the memory usage in your camera app. Let me start by analyzing the current code to identify potential memory leaks and inefficient memory usage patterns.

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [ ] 🌡️ Analyze PhotoProcessor.swift for memory issues
- [ ] 🌡️ Check PhotoDecorationService.swift for memory leaks
- [ ] 🌡️ Review camera capture flow for proper memory management
- [ ] 🌡️ Implement image memory optimization techniques
- [ ] 🌡️ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [⚡] 🌡️ Analyze PhotoProcessor.swift for memory issues
- [ ] 🌡️ Check PhotoDecorationService.swift for memory leaks
- [ ] 🌡️ Review camera capture flow for proper memory management
- [ ] 🌡️ Implement image memory optimization techniques
- [ ] 🌡️ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Core/Photo/PhotoProcessor.swift`

Result:

```
1→import UIKit
     2→import ImageIO
     3→import Photos
     4→import UniformTypeIdentifiers
     5→
     6→class PhotoProcessor {
     7→    private let locationManager: LocationManager
     8→    
     9→    init(locationManager: LocationManager) {
    10→        self.locationManager = locationManager
    11→    }
    12→    
    13→    func savePhotoToLibrary(_ imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio? = nil, frameSettings: FrameSettings? = nil) {
    14→        PHPhotoLibrary.requestAuthorization { [weak self] status in
    15→            guard status == .authorized else {
    16→                print("❌ 相册权限未授权")
    17→                return
    18→            }
    19→            
    20→            // 检查是否为超大图像，如果是则使用最简保存策略
    21→            if let self = self, self.isUltraLargeImage(imageData) {
    22→                print("🚨 检测到超大图像，使用紧急保存模式")
    23→                self.saveUltraLargeImageDirectly(imageData)
    24→                return
    25→            }
    26→            
    27→            // 使用autoreleasepool减少内存占用
    28→            autoreleasepool {
    29→                // 先检查原始数据是否包含完整元数据
    30→                self?.logOriginalMetadata(imageData)
    31→                
    32→                // 应用相框（如果设置了）
    33→                var processedImageData = imageData
    34→                if let frameSettings = frameSettings, frameSettings.selectedFrame != .none {
    35→                    let photoDecorationService = PhotoDecorationService(frameSettings: frameSettings)
    36→                    processedImageData = photoDecorationService.applyFrameToPhoto(imageData)
    37→                    print("✅ 已应用相框: \(frameSettings.selectedFrame.rawValue)")
    38→                }
    39→                
    40→                // 创建带有完整元数据的图像数据
    41→                guard let enhancedImageData = self?.createImageWithCompleteMetadata(from: processedImageData, format: format, aspectRatio: aspectRatio) else {
    42→                    print("❌ 无法创建带有完整元数据的图像")
    43→                    return
    44→                }
    45→                
    46→                // 保存到相册
    47→                self?.saveImageDataToPhotoLibrary(enhancedImageData)
    48→            }
    49→        }
    50→    }
    51→    
    52→    // 检查是否为超大图像
    53→    private func isUltraLargeImage(_ imageData: Data) -> Bool {
    54→        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
    55→              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
    56→              let width = properties[kCGImagePropertyPixelWidth as String] as? Int,
    57→              let height = properties[kCGImagePropertyPixelHeight as String] as? Int else {
    58→            return false
    59→        }
    60→        
    61→        let megapixels = (width * height) / 1_000_000
    62→        return megapixels >= 40 // 40MP以上认为是超大图像
    63→    }
    64→    
    65→    // 超大图像直接保存（零处理）
    66→    private func saveUltraLargeImageDirectly(_ imageData: Data) {
    67→        PHPhotoLibrary.shared().performChanges({
    68→            let creationRequest = PHAssetCreationRequest.forAsset()
    69→            
    70→            // 直接保存原始数据，不做任何处理
    71→            creationRequest.addResource(with: .photo, data: imageData, options: nil)
    72→            
    73→            // 如果有位置信息，添加GPS数据
    74→            if let location = self.locationManager.currentLocation {
    75→                creationRequest.location = location
    76→                print("📍 添加GPS位置信息: \(location.coordinate)")
    77→            }
    78→            
    79→        }) { success, error in
    80→            if let error = error {
    81→                print("❌ 超大图像保存失败: \(error)")
    82→            } else if success {
    83→                print("✅ 超大图像直接保存成功（零处理模式）")
    84→            }
    85→        }
    86→    }
    87→    
    88→    // 将保存到相册的操作提取为单独的方法，便于内存管理
    89→    private func saveImageDataToPhotoLibrary(_ imageData: Data) {
    90→        PHPhotoLibrary.shared().performChanges({ [weak self] in
    91→            let creationRequest = PHAssetCreationRequest.forAsset()
    92→            
    93→            // 使用增强后的图像数据
    94→            creationRequest.addResource(with: .photo, data: imageData, options: nil)
    95→            
    96→            // 如果有位置信息，添加GPS数据
    97→            if let location = self?.locationManager.currentLocation {
    98→                creationRequest.location = location
    99→                print("📍 添加GPS位置信息: \(location.coordinate)")
   100→            }
   101→            
   102→        }) { success, error in
   103→            if let error = error {
   104→                print("❌ 保存照片失败: \(error)")
   105→            } else if success {
   106→                print("✅ 照片已成功保存到相册，包含完整元数据")
   107→            }
   108→        }
   109→    }
   110→    
   111→    private func createImageWithCompleteMetadata(from imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio? = nil) -> Data? {
   112→        var resultData: Data?
   113→        
   114→        // 使用autoreleasepool减少内存占用
   115→        autoreleasepool {
   116→            guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else {
   117→                print("❌ 无法创建CGImageSource")
   118→                resultData = imageData // 返回原始数据作为备选
   119→                return
   120→            }
   121→            
   122→            // 🚨 关键优化：先检查图像尺寸，避免加载巨大图像到内存
   123→            guard let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
   124→                  let originalWidth = properties[kCGImagePropertyPixelWidth as String] as? Int,
   125→                  let originalHeight = properties[kCGImagePropertyPixelHeight as String] as? Int else {
   126→                print("❌ 无法获取图像属性")
   127→                resultData = imageData
   128→                return
   129→            }
   130→            
   131→            let originalMegapixels = (originalWidth * originalHeight) / 1_000_000
   132→            
   133→            print("🔍 原始图像尺寸检查:")
   134→            print("  - 宽度: \(originalWidth)")
   135→            print("  - 高度: \(originalHeight)")
   136→            print("  - 总像素: \(originalMegapixels)MP")
   137→            print("  - 是否为48MP: \(originalMegapixels >= 40)")
   138→            
   139→            // 🚨 48MP图像特殊处理：避免内存爆炸
   140→            if originalMegapixels >= 40 {
   141→                print("🚨 检测到48MP图像！启用极简处理模式")
   142→                resultData = handleUltraHighResolutionImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   143→                return
   144→            } else if originalMegapixels >= 20 {
   145→                print("⚡ 检测到大尺寸图像，启用优化处理")
   146→                resultData = handleLargeImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   147→                return
   148→            }
   149→            
   150→            print("✅ 标准图像，使用常规处理")
   151→            
   152→            // 常规图像处理（小于20MP）
   153→            guard let cgImage = CGImageSourceCreateImageAtIndex(source, 0, nil) else {
   154→                print("❌ 无法创建CGImage")
   155→                resultData = imageData
   156→                return
   157→            }
   158→            
   159→            // 处理比例裁剪
   160→            let finalCGImage: CGImage
   161→            if let aspectRatio = aspectRatio, aspectRatio != .ratio4_3 {
   162→                print("🔄 应用比例裁剪: \(aspectRatio.rawValue)")
   163→                finalCGImage = cropImageToAspectRatio(cgImage, aspectRatio: aspectRatio)
   164→            } else {
   165→                print("📷 保持原始比例")
   166→                finalCGImage = cgImage
   167→            }
   168→            
   169→            // 获取原始元数据 - 优化：只获取需要的元数据
   170→            var metadata: [String: Any] = [:]
   171→            if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   172→                // 只复制需要的元数据字典
   173→                if let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   174→                    metadata[kCGImagePropertyExifDictionary as String] = exif
   175→                }
   176→                if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   177→                    metadata[kCGImagePropertyTIFFDictionary as String] = tiff
   178→                }
   179→                if let gps = properties[kCGImagePropertyGPSDictionary as String] as? [String: Any] {
   180→                    metadata[kCGImagePropertyGPSDictionary as String] = gps
   181→                }
   182→            }
   183→            
   184→            print("📸 原始元数据字段:")
   185→            print("  - 总字段数: \(metadata.keys.count)")
   186→            
   187→            // 保留并补充EXIF信息（不覆盖已有的重要信息）
   188→            var exifDict = metadata[kCGImagePropertyExifDictionary as String] as? [String: Any] ?? [:]
   189→            
   190→            // 只在没有镜头信息时才添加
   191→            if exifDict[kCGImagePropertyExifLensMake as String] == nil {
   192→                exifDict[kCGImagePropertyExifLensMake as String] = "Apple"
   193→            }
   194→            if exifDict[kCGImagePropertyExifLensModel as String] == nil {
   195→                exifDict[kCGImagePropertyExifLensModel as String] = DeviceInfoHelper.getLensModelForPhotos(device: AVCaptureDevice.default(for: .video)!)
   196→            }
   197→            
   198→            // 添加拍摄时间（如果没有的话）
   199→            if exifDict[kCGImagePropertyExifDateTimeOriginal as String] == nil {
   200→                let now = Date()
   201→                let dateFormatter = DateFormatter()
   202→                dateFormatter.dateFormat = "yyyy:MM:dd HH:mm:ss"
   203→                exifDict[kCGImagePropertyExifDateTimeOriginal as String] = dateFormatter.string(from: now)
   204→                exifDict[kCGImagePropertyExifDateTimeDigitized as String] = dateFormatter.string(from: now)
   205→            }
   206→            
   207→            // 保留并补充TIFF信息
   208→            var tiffDict = metadata[kCGImagePropertyTIFFDictionary as String] as? [String: Any] ?? [:]
   209→            
   210→            // 只在没有设备信息时才添加
   211→            if tiffDict[kCGImagePropertyTIFFMake as String] == nil {
   212→                tiffDict[kCGImagePropertyTIFFMake as String] = "Apple"
   213→            }
   214→            if tiffDict[kCGImagePropertyTIFFModel as String] == nil {
   215→                tiffDict[kCGImagePropertyTIFFModel as String] = DeviceInfoHelper.getDetailedDeviceModel()
   216→            }
   217→            if tiffDict[kCGImagePropertyTIFFSoftware as String] == nil {
   218→                tiffDict[kCGImagePropertyTIFFSoftware as String] = "MCCamera 1.0.0"
   219→            }
   220→            
   221→            // 添加时间戳（如果没有的话）
   222→            if tiffDict[kCGImagePropertyTIFFDateTime as String] == nil {
   223→                let now = Date()
   224→                let dateFormatter = DateFormatter()
   225→                dateFormatter.dateFormat = "yyyy:MM:dd HH:mm:ss"
   226→                tiffDict[kCGImagePropertyTIFFDateTime as String] = dateFormatter.string(from: now)
   227→            }
   228→            
   229→            // 添加GPS信息（如果有位置数据且没有GPS信息）
   230→            if metadata[kCGImagePropertyGPSDictionary as String] == nil,
   231→               let gpsMetadata = locationManager.getLocationMetadata() {
   232→                metadata[kCGImagePropertyGPSDictionary as String] = gpsMetadata
   233→            }
   234→            
   235→            // 更新元数据
   236→            metadata[kCGImagePropertyExifDictionary as String] = exifDict
   237→            metadata[kCGImagePropertyTIFFDictionary as String] = tiffDict
   238→            
   239→            // 根据格式和图像大小选择输出类型
   240→            let outputType: CFString
   241→            let compressionQuality: Float
   242→            
   243→            // 🔄 关键优化：对于大尺寸图像，使用JPEG格式而不是HEIC格式
   244→            let useJpegForLargeImages = originalMegapixels > 20
   245→            
   246→            switch format {
   247→            case .heic:
   248→                if useJpegForLargeImages {
   249→                    print("📸 大尺寸图像(\(originalMegapixels)MP)，使用JPEG格式代替HEIC以减少内存使用")
   250→                    outputType = UTType.jpeg.identifier as CFString
   251→                    compressionQuality = 0.85 // 降低压缩质量以减少内存使用
   252→                } else {
   253→                    print("  - 转换为HEIC格式...")
   254→                    outputType = UTType.heic.identifier as CFString
   255→                    compressionQuality = 0.85 // 降低压缩质量以减少内存使用
   256→                }
   257→            case .jpeg:
   258→                outputType = UTType.jpeg.identifier as CFString
   259→                compressionQuality = 0.85 // 降低压缩质量以减少内存使用
   260→            case .raw:
   261→                // RAW格式通常不需要重新编码，直接返回原始数据
   262→                print("📸 RAW格式保持原始数据")
   263→                resultData = imageData
   264→                return
   265→            }
   266→            
   267→            // 🔄 关键优化：智能处理大尺寸图像
   268→            let processedCGImage: CGImage
   269→            if originalMegapixels > 30 { // 对于非常大的图像（如48MP）
   270→                print("📸 使用内存优化策略处理大尺寸图像")
   271→                processedCGImage = processLargeImageWithMemoryOptimization(finalCGImage, originalMegapixels: originalMegapixels)
   272→            } else {
   273→                processedCGImage = finalCGImage
   274→            }
   275→            
   276→            // 创建新的图像数据
   277→            let mutableData = NSMutableData()
   278→            guard let destination = CGImageDestinationCreateWithData(mutableData, outputType, 1, nil) else {
   279→                print("❌ 无法创建CGImageDestination")
   280→                resultData = imageData
   281→                return
   282→            }
   283→            
   284→            // 设置压缩质量和其他选项
   285→            var options: [CFString: Any] = [
   286→                kCGImageDestinationLossyCompressionQuality: compressionQuality,
   287→                kCGImageDestinationOptimizeColorForSharing: true // 优化颜色共享
   288→            ]
   289→            
   290→            // 对于HEIC格式，添加额外的优化选项
   291→            if outputType == UTType.heic.identifier as CFString {
   292→                options[kCGImageDestinationEmbedThumbnail] = false // 不嵌入缩略图以减少内存使用
   293→            }
   294→            
   295→            // 先设置属性，再添加图像
   296→            CGImageDestinationSetProperties(destination, options as CFDictionary)
   297→            
   298→            // 添加图像和元数据
   299→            CGImageDestinationAddImage(destination, processedCGImage, metadata as CFDictionary)
   300→            
   301→            // 完成写入
   302→            guard CGImageDestinationFinalize(destination) else {
   303→                print("❌ 无法完成图像写入")
   304→                resultData = imageData
   305→                return
   306→            }
   307→            
   308→            // 验证保存的元数据
   309→            verifyMetadata(mutableData)
   310→            
   311→            print("✅ 成功创建带有完整元数据的图像，格式: \(outputType == UTType.heic.identifier as CFString ? "HEIC" : "JPEG")")
   312→            resultData = mutableData as Data
   313→        }
   314→        
   315→        return resultData
   316→    }
   317→    
   318→    // 48MP图像极简处理 - 避免内存爆炸
   319→    private func handleUltraHighResolutionImage(source: CGImageSource, imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio?) -> Data {
   320→        print("🔥 48MP极简处理模式")
   321→        
   322→        // 检查当前内存压力
   323→        let memoryUsage = MemoryMonitor.shared.getCurrentMemoryUsage()
   324→        let usedMB = memoryUsage.used / 1024 / 1024
   325→        
   326→        // 如果内存压力极大，直接返回原始数据
   327→        if usedMB > 300 {
   328→            print("🚨 内存压力过大(\(usedMB)MB)，直接保存原始数据")
   329→            return imageData
   330→        }
   331→        
   332→        // 如果没有裁剪需求且格式匹配，直接返回原始数据
   333→        if aspectRatio == nil || aspectRatio == .ratio4_3 {
   334→            print("🚀 无需处理，直接保存原始48MP数据")
   335→            return imageData
   336→        }
   337→        
   338→        print("📝 添加最少元数据后保存")
   339→        
   340→        // 只在必要时添加最少的元数据
   341→        var metadata: [String: Any] = [:]
   342→        
   343→        // 获取原始属性（轻量级操作）
   344→        if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   345→            // 只保留最重要的元数据
   346→            if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   347→                var tiffDict = tiff
   348→                tiffDict[kCGImagePropertyTIFFSoftware as String] = "MCCamera 1.0.0"
   349→                metadata[kCGImagePropertyTIFFDictionary as String] = tiffDict
   350→            }
   351→        }
   352→        
   353→        // 使用最简单的重写方式
   354→        let mutableData = NSMutableData()
   355→        let outputType = UTType.heic.identifier as CFString // 保持原格式
   356→        
   357→        guard let destination = CGImageDestinationCreateWithData(mutableData, outputType, 1, nil) else {
   358→            print("❌ 创建destination失败，返回原始数据")
   359→            return imageData
   360→        }
   361→        
   362→        // 最小化的处理选项
   363→        let options: [CFString: Any] = [
   364→            kCGImageDestinationLossyCompressionQuality: 0.95 // 最小压缩
   365→        ]
   366→        
   367→        CGImageDestinationSetProperties(destination, options as CFDictionary)
   368→        
   369→        // 零拷贝策略：直接从source到destination
   370→        CGImageDestinationAddImageFromSource(destination, source, 0, metadata as CFDictionary)
   371→        
   372→        guard CGImageDestinationFinalize(destination) else {
   373→            print("❌ 写入失败，返回原始数据")
   374→            return imageData
   375→        }
   376→        
   377→        print("✅ 48MP最小化处理完成")
   378→        return mutableData as Data
   379→    }
   380→    
   381→    // 大图像优化处理（20-40MP）
   382→    private func handleLargeImage(source: CGImageSource, imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio?) -> Data {
   383→        print("⚡ 大图像优化处理")
   384→        
   385→        // 使用降采样技术，避免将完整图像加载到内存
   386→        let maxPixelSize = 3000 // 限制最大边长为3000px
   387→        
   388→        let options: [CFString: Any] = [
   389→            kCGImageSourceCreateThumbnailFromImageAlways: true,
   390→            kCGImageSourceCreateThumbnailWithTransform: true,
   391→            kCGImageSourceThumbnailMaxPixelSize: maxPixelSize,
   392→            kCGImageSourceShouldCache: false
   393→        ]
   394→        
   395→        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
   396→            print("❌ 大图像降采样失败，返回原始数据")
   397→            return imageData
   398→        }
   399→        
   400→        print("📉 大图像已降采样至: \(downsampledImage.width)×\(downsampledImage.height)")
   401→        
   402→        // 获取元数据
   403→        var metadata: [String: Any] = [:]
   404→        if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   405→            if let exif = properties[kCGImagePropertyExifDictionary as String] {
   406→                metadata[kCGImagePropertyExifDictionary as String] = exif
   407→            }
   408→            if let tiff = properties[kCGImagePropertyTIFFDictionary as String] {
   409→                metadata[kCGImagePropertyTIFFDictionary as String] = tiff
   410→            }
   411→        }
   412→        
   413→        // 创建输出
   414→        let mutableData = NSMutableData()
   415→        let outputType = UTType.jpeg.identifier as CFString
   416→        guard let destination = CGImageDestinationCreateWithData(mutableData, outputType, 1, nil) else {
   417→            return imageData
   418→        }
   419→        
   420→        let compressionOptions: [CFString: Any] = [
   421→            kCGImageDestinationLossyCompressionQuality: 0.8
   422→        ]
   423→        
   424→        CGImageDestinationAddImage(destination, downsampledImage, metadata as CFDictionary)
   425→        CGImageDestinationSetProperties(destination, compressionOptions as CFDictionary)
   426→        
   427→        guard CGImageDestinationFinalize(destination) else {
   428→            return imageData
   429→        }
   430→        
   431→        print("✅ 大图像优化处理完成")
   432→        return mutableData as Data
   433→    }
   434→    
   435→    // 内存优化的大图像处理
   436→    private func processLargeImageWithMemoryOptimization(_ cgImage: CGImage, originalMegapixels: Int) -> CGImage {
   437→        var result = cgImage
   438→        
   439→        autoreleasepool {
   440→            // 计算目标尺寸 - 智能缩放到合适大小
   441→            let targetMegapixels = min(Double(originalMegapixels), 25.0) // 最大25MP
   442→            let scaleFactor = sqrt(targetMegapixels / Double(originalMegapixels))
   443→            
   444→            let newWidth = Int(Double(cgImage.width) * scaleFactor)
   445→            let newHeight = Int(Double(cgImage.height) * scaleFactor)
   446→            
   447→            print("📸 智能缩放: \(cgImage.width)×\(cgImage.height) -> \(newWidth)×\(newHeight) (缩放因子: \(scaleFactor))")
   448→            
   449→            // 使用更精确的缩放算法
   450→            if let scaledImage = createHighQualityScaledImage(from: cgImage, targetSize: CGSize(width: newWidth, height: newHeight)) {
   451→                result = scaledImage
   452→                print("✅ 大图像内存优化完成")
   453→            } else {
   454→                print("⚠️ 大图像缩放失败，使用原图")
   455→            }
   456→        }
   457→        
   458→        return result
   459→    }
   460→    
   461→    // 创建高质量缩放图像
   462→    private func createHighQualityScaledImage(from cgImage: CGImage, targetSize: CGSize) -> CGImage? {
   463→        autoreleasepool {
   464→            // 使用内存效率更高的颜色空间
   465→            let colorSpace = CGColorSpaceCreateDeviceRGB()
   466→            
   467→            // 计算合适的字节对齐
   468→            let bytesPerRow = Int(targetSize.width) * 4
   469→            let alignedBytesPerRow = (bytesPerRow + 15) & ~15 // 16字节对齐优化性能
   470→            
   471→            guard let context = CGContext(
   472→                data: nil,
   473→                width: Int(targetSize.width),
   474→                height: Int(targetSize.height),
   475→                bitsPerComponent: 8,
   476→                bytesPerRow: alignedBytesPerRow,
   477→                space: colorSpace,
   478→                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue | CGBitmapInfo.byteOrder32Big.rawValue
   479→            ) else {
   480→                print("❌ 无法创建优化的图形上下文")
   481→                return nil
   482→            }
   483→            
   484→            // 设置高质量插值
   485→            context.interpolationQuality = .high
   486→            
   487→            // 绘制缩放后的图像
   488→            context.draw(cgImage, in: CGRect(origin: .zero, size: targetSize))
   489→            
   490→            return context.makeImage()
   491→        }
   492→    }
   493→    
   494→    private func verifyMetadata(_ data: NSMutableData) {
   495→        autoreleasepool {
   496→            if let verifySource = CGImageSourceCreateWithData(data, nil),
   497→               let verifyMetadata = CGImageSourceCopyPropertiesAtIndex(verifySource, 0, nil) as? [String: Any] {
   498→                print("📋 验证保存的元数据:")
   499→                
   500→                if let verifyExif = verifyMetadata[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   501→                    print("  - EXIF字段数量: \(verifyExif.keys.count)")
   502→                    if let lensMake = verifyExif[kCGImagePropertyExifLensMake as String] {
   503→                        print("  - 镜头制造商: \(lensMake)")
   504→                    }
   505→                    if let lensModel = verifyExif[kCGImagePropertyExifLensModel as String] {
   506→                        print("  - 镜头型号: \(lensModel)")
   507→                    }
   508→                    if let dateTime = verifyExif[kCGImagePropertyExifDateTimeOriginal as String] {
   509→                        print("  - 拍摄时间: \(dateTime)")
   510→                    }
   511→                    if let iso = verifyExif[kCGImagePropertyExifISOSpeedRatings as String] {
   512→                        print("  - ISO: \(iso)")
   513→                    }
   514→                    if let exposureTime = verifyExif[kCGImagePropertyExifExposureTime as String] {
   515→                        print("  - 快门速度: \(exposureTime)")
   516→                    }
   517→                }
   518→                
   519→                if let verifyTiff = verifyMetadata[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   520→                    print("  - TIFF字段数量: \(verifyTiff.keys.count)")
   521→                    if let make = verifyTiff[kCGImagePropertyTIFFMake as String] {
   522→                        print("  - 设备制造商: \(make)")
   523→                    }
   524→                    if let model = verifyTiff[kCGImagePropertyTIFFModel as String] {
   525→                        print("  - 设备型号: \(model)")
   526→                    }
   527→                }
   528→                
   529→                if let verifyGPS = verifyMetadata[kCGImagePropertyGPSDictionary as String] as? [String: Any] {
   530→                    print("  - GPS字段数量: \(verifyGPS.keys.count)")
   531→                } else {
   532→                    print("  - 无GPS信息")
   533→                }
   534→            } else {
   535→                print("❌ 无法验证保存的元数据")
   536→            }
   537→        }
   538→    }
   539→    
   540→    private func cropImageToAspectRatio(_ cgImage: CGImage, aspectRatio: AspectRatio) -> CGImage {
   541→        let originalWidth = cgImage.width
   542→        let originalHeight = cgImage.height
   543→        let originalSize = CGSize(width: originalWidth, height: originalHeight)
   544→        
   545→        print("🔄 裁剪图像:")
   546→        print("  - 原始尺寸: \(originalWidth) x \(originalHeight)")
   547→        print("  - 目标比例: \(aspectRatio.rawValue) (\(aspectRatio.ratioValue))")
   548→        
   549→        // 计算裁剪区域
   550→        let cropRect = aspectRatio.getCropRect(for: originalSize)
   551→        
   552→        print("  - 裁剪区域: \(cropRect)")
   553→        print("  - 裁剪后尺寸: \(Int(cropRect.width)) x \(Int(cropRect.height))")
   554→        
   555→        // 执行裁剪
   556→        if let croppedImage = cgImage.cropping(to: cropRect) {
   557→            print("✅ 图像裁剪成功")
   558→            return croppedImage
   559→        } else {
   560→            print("❌ 图像裁剪失败，返回原图")
   561→            return cgImage
   562→        }
   563→    }
   564→    
   565→    private func logOriginalMetadata(_ imageData: Data) {
   566→        autoreleasepool {
   567→            guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
   568→                  let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] else {
   569→                print("📸 无法读取原始照片元数据")
   570→                return
   571→            }
   572→            
   573→            print("📸 原始照片元数据:")
   574→            if let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   575→                print("  - EXIF数据存在，包含 \(exif.keys.count) 个字段")
   576→                if let iso = exif[kCGImagePropertyExifISOSpeedRatings as String] {
   577→                    print("  - ISO: \(iso)")
   578→                }
   579→                if let exposureTime = exif[kCGImagePropertyExifExposureTime as String] {
   580→                    print("  - 快门速度: \(exposureTime)")
   581→                }
   582→            } else {
   583→                print("  - 无EXIF数据")
   584→            }
   585→            
   586→            if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   587→                print("  - TIFF数据存在")
   588→                if let make = tiff[kCGImagePropertyTIFFMake as String] {
   589→                    print("  - 制造商: \(make)")
   590→                }
   591→            }
   592→        }
   593→    }
   594→}
```

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] 🌡️ Analyze PhotoProcessor.swift for memory issues
- [⚡] 🌡️ Check PhotoDecorationService.swift for memory leaks
- [ ] 🌡️ Review camera capture flow for proper memory management
- [ ] 🌡️ Implement image memory optimization techniques
- [ ] 🌡️ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Features/Frame/Services/PhotoDecorationService.swift`

Result:

```
1→import Foundation
     2→import UIKit
     3→import CoreLocation
     4→
     5→class PhotoDecorationService {
     6→    private let frameSettings: FrameSettings
     7→    private let renderer: OptimizedPhotoDecorationRenderer
     8→    private let layoutEngine: InfoLayoutEngine
     9→    
    10→    init(frameSettings: FrameSettings) {
    11→        self.frameSettings = frameSettings
    12→        self.renderer = OptimizedPhotoDecorationRenderer()
    13→        self.layoutEngine = InfoLayoutEngine()
    14→    }
    15→    
    16→    // 应用相框到照片 - 极端内存优化版本
    17→    func applyFrameToPhoto(_ imageData: Data) -> Data {
    18→        // 如果没有选择相框，直接返回原图
    19→        guard frameSettings.selectedFrame != .none else {
    20→            return imageData
    21→        }
    22→        
    23→        var finalImageData = imageData
    24→        
    25→        // 内存监控和压力检查
    26→        MemoryMonitor.shared.logMemoryUsage(context: "相框处理开始")
    27→        
    28→        // 根据内存压力调整处理策略
    29→        let processingStrategy = MemoryPressureManager.shared.getOptimalProcessingStrategy()
    30→        let pixelCount = getImagePixelCount(from: imageData)
    31→        
    32→        print("📊 处理图像像素数: \(pixelCount / 1_000_000)MP，策略: \(processingStrategy)")
    33→        
    34→        // 如果内存压力过大，执行预防性清理
    35→        MemoryPressureManager.shared.performPreventiveCleanup()
    36→        
    37→        // 使用多层autoreleasepool减少内存峰值
    38→        autoreleasepool {
    39→            // 第一层：获取元数据（轻量级操作）
    40→            MemoryMonitor.shared.logMemoryUsage(context: "元数据提取开始")
    41→            let metadata = getMetadataFromImageData(imageData)
    42→            MemoryMonitor.shared.logMemoryUsage(context: "元数据提取完成")
    43→            
    44→            autoreleasepool {
    45→                // 第二层：图像处理（基于内存压力调整）
    46→                MemoryMonitor.shared.logMemoryUsage(context: "图像优化创建开始")
    47→                guard let image = createAdaptiveOptimizedImage(from: imageData, pixelCount: pixelCount, strategy: processingStrategy) else {
    48→                    print("❌ 无法创建优化图像")
    49→                    return
    50→                }
    51→                MemoryMonitor.shared.logMemoryUsage(context: "图像优化创建完成")
    52→                
    53→                print("📱 使用图像尺寸: \(Int(image.size.width))×\(Int(image.size.height))")
    54→                
    55→                autoreleasepool {
    56→                    // 第三层：渲染装饰
    57→                    MemoryMonitor.shared.logMemoryUsage(context: "相框渲染开始")
    58→                    let decoratedImage = renderer.renderDecoration(
    59→                        on: image,
    60→                        frameType: frameSettings.selectedFrame,
    61→                        customText: frameSettings.customText,
    62→                        showDate: frameSettings.showDate,
    63→                        showLocation: frameSettings.showLocation,
    64→                        showExif: frameSettings.showExif,
    65→                        showExifParams: frameSettings.showExifParams,
    66→                        showExifDate: frameSettings.showExifDate,
    67→                        selectedLogo: frameSettings.selectedLogo,
    68→                        showSignature: frameSettings.showSignature,
    69→                        metadata: metadata
    70→                    )
    71→                    MemoryMonitor.shared.logMemoryUsage(context: "相框渲染完成")
    72→                    
    73→                    // 转换回Data - 使用自适应压缩策略
    74→                    autoreleasepool {
    75→                        MemoryMonitor.shared.logMemoryUsage(context: "图像压缩开始")
    76→                        let compressionQuality = processingStrategy.compressionQuality
    77→                        if let processedData = decoratedImage.jpegData(compressionQuality: compressionQuality) {
    78→                            finalImageData = processedData
    79→                            print("✅ 图像处理完成，策略: \(processingStrategy)，压缩质量: \(compressionQuality)")
    80→                        }
    81→                        MemoryMonitor.shared.logMemoryUsage(context: "图像压缩完成")
    82→                    }
    83→                }
    84→            }
    85→        }
    86→        
    87→        MemoryMonitor.shared.logMemoryUsage(context: "相框处理结束")
    88→        
    89→        // 检查是否需要强制清理内存
    90→        if MemoryMonitor.shared.shouldTriggerMemoryCleanup() {
    91→            MemoryMonitor.shared.forceMemoryCleanup()
    92→        }
    93→        
    94→        return finalImageData
    95→    }
    96→    
    97→    // 获取图像像素数
    98→    private func getImagePixelCount(from imageData: Data) -> Int {
    99→        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
   100→              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
   101→              let width = properties[kCGImagePropertyPixelWidth as String] as? Int,
   102→              let height = properties[kCGImagePropertyPixelHeight as String] as? Int else {
   103→            return 0
   104→        }
   105→        return width * height
   106→    }
   107→    
   108→    // 基于内存压力的自适应图像创建
   109→    private func createAdaptiveOptimizedImage(from imageData: Data, pixelCount: Int, strategy: ImageProcessingStrategy) -> UIImage? {
   110→        let maxPixels = strategy.maxPixels
   111→        
   112→        print("🎯 自适应处理：像素数\(pixelCount/1_000_000)MP，限制\(maxPixels/1_000_000)MP")
   113→        
   114→        // 根据策略决定处理方式
   115→        switch strategy {
   116→        case .ultraLowMemory:
   117→            // 极端内存不足：最激进压缩
   118→            print("🚨 极端内存模式")
   119→            return createUltraDownsampledImage(from: imageData, maxPixels: maxPixels)
   120→            
   121→        case .lowMemory:
   122→            // 内存紧张：激进压缩
   123→            print("⚡ 低内存模式")
   124→            if pixelCount > maxPixels {
   125→                return createDownsampledImage(from: imageData, maxPixels: maxPixels)
   126→            } else {
   127→                return UIImage(data: imageData)
   128→            }
   129→            
   130→        case .standard:
   131→            // 内存充足：标准处理
   132→            print("✅ 标准模式")
   133→            return createOptimizedUIImage(from: imageData, pixelCount: pixelCount)
   134→        }
   135→    }
   136→    
   137→    // 创建内存优化的UIImage - 极端优化版本
   138→    private func createOptimizedUIImage(from imageData: Data, pixelCount: Int) -> UIImage? {
   139→        // 更激进的内存控制策略
   140→        if pixelCount > 48_000_000 { // 48MP - 极端压缩
   141→            print("🚨 检测到48MP图像，启用极端内存优化")
   142→            return createUltraDownsampledImage(from: imageData, maxPixels: 8_000_000) // 降至8MP
   143→        } else if pixelCount > 20_000_000 { // 20MP+ - 激进压缩
   144→            print("⚡ 检测到大图像，启用激进内存优化")
   145→            return createDownsampledImage(from: imageData, maxPixels: 12_000_000) // 降至12MP
   146→        } else if pixelCount > 10_000_000 { // 10MP+ - 适度压缩
   147→            return createDownsampledImage(from: imageData, maxPixels: 8_000_000) // 降至8MP
   148→        } else {
   149→            // 小图像直接创建
   150→            return UIImage(data: imageData)
   151→        }
   152→    }
   153→    
   154→    // 极端降采样图像（用于48MP等超大图像）
   155→    private func createUltraDownsampledImage(from imageData: Data, maxPixels: Int) -> UIImage? {
   156→        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }
   157→        
   158→        // 使用最小内存配置
   159→        let options: [CFString: Any] = [
   160→            kCGImageSourceCreateThumbnailFromImageAlways: true,
   161→            kCGImageSourceCreateThumbnailWithTransform: true,
   162→            kCGImageSourceThumbnailMaxPixelSize: Int(sqrt(Double(maxPixels))), // 更保守的尺寸计算
   163→            kCGImageSourceShouldCache: false, // 禁用缓存
   164→            kCGImageSourceShouldAllowFloat: false // 禁用浮点数处理
   165→        ]
   166→        
   167→        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else { return nil }
   168→        
   169→        let finalWidth = downsampledImage.width
   170→        let finalHeight = downsampledImage.height
   171→        let finalPixels = finalWidth * finalHeight
   172→        
   173→        print("🔥 极端降采样完成: \(finalWidth)×\(finalHeight) (\(finalPixels/1_000_000)MP)")
   174→        
   175→        return UIImage(cgImage: downsampledImage)
   176→    }
   177→    
   178→    // 标准降采样图像
   179→    private func createDownsampledImage(from imageData: Data, maxPixels: Int) -> UIImage? {
   180→        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }
   181→        
   182→        // 获取原始尺寸
   183→        guard let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
   184→              let originalWidth = properties[kCGImagePropertyPixelWidth as String] as? Int,
   185→              let originalHeight = properties[kCGImagePropertyPixelHeight as String] as? Int else { return nil }
   186→        
   187→        // 计算降采样比例
   188→        let originalPixels = originalWidth * originalHeight
   189→        let scale = sqrt(Double(maxPixels) / Double(originalPixels))
   190→        
   191→        let targetSize = Int(Double(max(originalWidth, originalHeight)) * scale)
   192→        
   193→        print("📉 标准降采样: \(originalWidth)×\(originalHeight) -> 最大边长\(targetSize)")
   194→        
   195→        // 创建降采样选项
   196→        let options: [CFString: Any] = [
   197→            kCGImageSourceCreateThumbnailFromImageAlways: true,
   198→            kCGImageSourceCreateThumbnailWithTransform: true,
   199→            kCGImageSourceThumbnailMaxPixelSize: targetSize,
   200→            kCGImageSourceShouldCache: false // 禁用缓存减少内存使用
   201→        ]
   202→        
   203→        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else { return nil }
   204→        
   205→        return UIImage(cgImage: downsampledImage)
   206→    }
   207→    
   208→    // 从图像数据中提取元数据 - 优化版本
   209→    private func getMetadataFromImageData(_ imageData: Data) -> [String: Any] {
   210→        var metadata: [String: Any] = [:]
   211→        
   212→        // 使用autoreleasepool减少内存占用
   213→        autoreleasepool {
   214→            if let source = CGImageSourceCreateWithData(imageData as CFData, nil) {
   215→                // 只获取需要的元数据，避免复制整个元数据字典
   216→                if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   217→                    // 提取EXIF信息
   218→                    if let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   219→                        // 只复制需要的EXIF字段
   220→                        var exifSubset: [String: Any] = [:]
   221→                        
   222→                        // ISO
   223→                        if let iso = exif[kCGImagePropertyExifISOSpeedRatings as String] {
   224→                            exifSubset[kCGImagePropertyExifISOSpeedRatings as String] = iso
   225→                        }
   226→                        
   227→                        // 光圈
   228→                        if let aperture = exif[kCGImagePropertyExifFNumber as String] {
   229→                            exifSubset[kCGImagePropertyExifFNumber as String] = aperture
   230→                        }
   231→                        
   232→                        // 快门速度
   233→                        if let shutterSpeed = exif[kCGImagePropertyExifExposureTime as String] {
   234→                            exifSubset[kCGImagePropertyExifExposureTime as String] = shutterSpeed
   235→                        }
   236→                        
   237→                        // 焦距
   238→                        if let focalLength = exif[kCGImagePropertyExifFocalLength as String] {
   239→                            exifSubset[kCGImagePropertyExifFocalLength as String] = focalLength
   240→                        }
   241→                        
   242→                        // 日期时间
   243→                        if let dateTime = exif[kCGImagePropertyExifDateTimeOriginal as String] {
   244→                            exifSubset[kCGImagePropertyExifDateTimeOriginal as String] = dateTime
   245→                        }
   246→                        
   247→                        metadata["exif"] = exifSubset
   248→                    }
   249→                    
   250→                    // 提取TIFF信息
   251→                    if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   252→                        // 只复制需要的TIFF字段
   253→                        var tiffSubset: [String: Any] = [:]
   254→                        
   255→                        // 制造商
   256→                        if let make = tiff[kCGImagePropertyTIFFMake as String] {
   257→                            tiffSubset[kCGImagePropertyTIFFMake as String] = make
   258→                        }
   259→                        
   260→                        // 型号
   261→                        if let model = tiff[kCGImagePropertyTIFFModel as String] {
   262→                            tiffSubset[kCGImagePropertyTIFFModel as String] = model
   263→                        }
   264→                        
   265→                        metadata["tiff"] = tiffSubset
   266→                    }
   267→                    
   268→                    // 提取GPS信息
   269→                    if let gps = properties[kCGImagePropertyGPSDictionary as String] as? [String: Any] {
   270→                        // 只复制需要的GPS字段
   271→                        var gpsSubset: [String: Any] = [:]
   272→                        
   273→                        // 纬度
   274→                        if let latitude = gps[kCGImagePropertyGPSLatitude as String] {
   275→                            gpsSubset[kCGImagePropertyGPSLatitude as String] = latitude
   276→                        }
   277→                        
   278→                        // 纬度参考
   279→                        if let latitudeRef = gps[kCGImagePropertyGPSLatitudeRef as String] {
   280→                            gpsSubset[kCGImagePropertyGPSLatitudeRef as String] = latitudeRef
   281→                        }
   282→                        
   283→                        // 经度
   284→                        if let longitude = gps[kCGImagePropertyGPSLongitude as String] {
   285→                            gpsSubset[kCGImagePropertyGPSLongitude as String] = longitude
   286→                        }
   287→                        
   288→                        // 经度参考
   289→                        if let longitudeRef = gps[kCGImagePropertyGPSLongitudeRef as String] {
   290→                            gpsSubset[kCGImagePropertyGPSLongitudeRef as String] = longitudeRef
   291→                        }
   292→                        
   293→                        metadata["gps"] = gpsSubset
   294→                    }
   295→                }
   296→            }
   297→        }
   298→        
   299→        return metadata
   300→    }
   301→}
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Features/Frame/Services/OptimizedPhotoDecorationRenderer.swift`

Result:

```
1→import UIKit
     2→import CoreLocation
     3→
     4→class OptimizedPhotoDecorationRenderer {
     5→    
     6→    // 内存优化配置 - 更激进的设置
     7→    private let maxRenderSize: CGFloat = 1536 // 进一步降低渲染尺寸以减少内存
     8→    private let memoryPressureThreshold: Int = 15_000_000 // 15MP以上使用特殊优化（更低阈值）
     9→    
    10→    // 渲染装饰到照片上 - 内存优化版本
    11→    func renderDecoration(
    12→        on image: UIImage,
    13→        frameType: FrameType,
    14→        customText: String,
    15→        showDate: Bool,
    16→        showLocation: Bool,
    17→        showExif: Bool,
    18→        showExifParams: Bool,
    19→        showExifDate: Bool,
    20→        selectedLogo: String?,
    21→        showSignature: Bool,
    22→        metadata: [String: Any]
    23→    ) -> UIImage {
    24→        
    25→        let originalSize = image.size
    26→        let pixelCount = Int(originalSize.width * originalSize.height)
    27→        
    28→        // 对于超大图像使用特殊优化策略
    29→        if pixelCount > memoryPressureThreshold {
    30→            return renderLargeImageWithTiling(
    31→                image: image,
    32→                frameType: frameType,
    33→                customText: customText,
    34→                showDate: showDate,
    35→                showLocation: showLocation,
    36→                showExif: showExif,
    37→                showExifParams: showExifParams,
    38→                showExifDate: showExifDate,
    39→                selectedLogo: selectedLogo,
    40→                showSignature: showSignature,
    41→                metadata: metadata
    42→            )
    43→        } else {
    44→            return renderStandardImage(
    45→                image: image,
    46→                frameType: frameType,
    47→                customText: customText,
    48→                showDate: showDate,
    49→                showLocation: showLocation,
    50→                showExif: showExif,
    51→                showExifParams: showExifParams,
    52→                showExifDate: showExifDate,
    53→                selectedLogo: selectedLogo,
    54→                showSignature: showSignature,
    55→                metadata: metadata
    56→            )
    57→        }
    58→    }
    59→    
    60→    // 标准图像渲染（内存优化）
    61→    private func renderStandardImage(
    62→        image: UIImage,
    63→        frameType: FrameType,
    64→        customText: String,
    65→        showDate: Bool,
    66→        showLocation: Bool,
    67→        showExif: Bool,
    68→        showExifParams: Bool,
    69→        showExifDate: Bool,
    70→        selectedLogo: String?,
    71→        showSignature: Bool,
    72→        metadata: [String: Any]
    73→    ) -> UIImage {
    74→        
    75→        var result: UIImage?
    76→        
    77→        autoreleasepool {
    78→            guard let cgImage = image.cgImage else {
    79→                result = image
    80→                return
    81→            }
    82→            
    83→            let size = CGSize(width: cgImage.width, height: cgImage.height)
    84→            let colorSpace = CGColorSpaceCreateDeviceRGB()
    85→            
    86→            // 使用Core Graphics Context替代UIGraphics
    87→            guard let context = CGContext(
    88→                data: nil,
    89→                width: Int(size.width),
    90→                height: Int(size.height),
    91→                bitsPerComponent: 8,
    92→                bytesPerRow: 0,
    93→                space: colorSpace,
    94→                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
    95→            ) else {
    96→                result = image
    97→                return
    98→            }
    99→            
   100→            // 设置高质量渲染
   101→            context.interpolationQuality = .high
   102→            
   103→            // 绘制原始图像
   104→            context.draw(cgImage, in: CGRect(origin: .zero, size: size))
   105→            
   106→            // 根据相框类型应用装饰
   107→            switch frameType {
   108→            case .bottomText:
   109→                renderBottomTextFrameCG(
   110→                    context: context,
   111→                    imageSize: size,
   112→                    customText: customText,
   113→                    showDate: showDate,
   114→                    showLocation: showLocation,
   115→                    showExif: showExif,
   116→                    showExifParams: showExifParams,
   117→                    showExifDate: showExifDate,
   118→                    selectedLogo: selectedLogo,
   119→                    showSignature: showSignature,
   120→                    metadata: metadata
   121→                )
   122→                
   123→            case .centerWatermark:
   124→                renderCenterWatermarkFrameCG(
   125→                    context: context,
   126→                    imageSize: size,
   127→                    customText: customText,
   128→                    selectedLogo: selectedLogo,
   129→                    metadata: metadata
   130→                )
   131→                
   132→            case .magazineCover:
   133→                renderMagazineCoverFrameCG(
   134→                    context: context,
   135→                    imageSize: size,
   136→                    customText: customText,
   137→                    showDate: showDate,
   138→                    selectedLogo: selectedLogo,
   139→                    metadata: metadata
   140→                )
   141→                
   142→            case .polaroid:
   143→                renderPolaroidFrameCG(
   144→                    context: context,
   145→                    imageSize: size,
   146→                    customText: customText,
   147→                    showDate: showDate,
   148→                    metadata: metadata
   149→                )
   150→                
   151→            case .none:
   152→                break
   153→            }
   154→            
   155→            // 获取最终图像
   156→            if let finalCGImage = context.makeImage() {
   157→                result = UIImage(cgImage: finalCGImage, scale: image.scale, orientation: image.imageOrientation)
   158→            } else {
   159→                result = image
   160→            }
   161→        }
   162→        
   163→        return result ?? image
   164→    }
   165→    
   166→    // 大图像瓦片化渲染
   167→    private func renderLargeImageWithTiling(
   168→        image: UIImage,
   169→        frameType: FrameType,
   170→        customText: String,
   171→        showDate: Bool,
   172→        showLocation: Bool,
   173→        showExif: Bool,
   174→        showExifParams: Bool,
   175→        showExifDate: Bool,
   176→        selectedLogo: String?,
   177→        showSignature: Bool,
   178→        metadata: [String: Any]
   179→    ) -> UIImage {
   180→        
   181→        print("🚀 使用瓦片化渲染处理大图像...")
   182→        
   183→        var result: UIImage?
   184→        
   185→        autoreleasepool {
   186→            guard let cgImage = image.cgImage else {
   187→                result = image
   188→                return
   189→            }
   190→            
   191→            let originalSize = CGSize(width: cgImage.width, height: cgImage.height)
   192→            
   193→            // 计算缩放因子 - 更激进的缩小策略
   194→            let targetRenderSize = min(maxRenderSize, 1200) // 进一步限制最大尺寸
   195→            let scaleFactor = min(targetRenderSize / originalSize.width, targetRenderSize / originalSize.height, 0.5) // 最多只能是原尺寸的50%
   196→            let renderSize = CGSize(
   197→                width: originalSize.width * scaleFactor,
   198→                height: originalSize.height * scaleFactor
   199→            )
   200→            
   201→            print("📏 原始尺寸: \(Int(originalSize.width))×\(Int(originalSize.height))")
   202→            print("📏 渲染尺寸: \(Int(renderSize.width))×\(Int(renderSize.height))")
   203→            print("📏 缩放因子: \(scaleFactor)")
   204→            
   205→            // 第一步：创建缩小的渲染版本
   206→            let scaledImage = createScaledImage(from: cgImage, size: renderSize)
   207→            
   208→            // 第二步：在小图上渲染装饰
   209→            let decoratedSmallImage = renderStandardImage(
   210→                image: UIImage(cgImage: scaledImage),
   211→                frameType: frameType,
   212→                customText: customText,
   213→                showDate: showDate,
   214→                showLocation: showLocation,
   215→                showExif: showExif,
   216→                showExifParams: showExifParams,
   217→                showExifDate: showExifDate,
   218→                selectedLogo: selectedLogo,
   219→                showSignature: showSignature,
   220→                metadata: metadata
   221→            )
   222→            
   223→            // 第三步：将装饰后的图像放大回原始尺寸
   224→            if let decoratedCGImage = decoratedSmallImage.cgImage {
   225→                let finalImage = createScaledImage(from: decoratedCGImage, size: originalSize)
   226→                result = UIImage(cgImage: finalImage, scale: image.scale, orientation: image.imageOrientation)
   227→            } else {
   228→                result = image
   229→            }
   230→        }
   231→        
   232→        print("✅ 瓦片化渲染完成")
   233→        return result ?? image
   234→    }
   235→    
   236→    // 创建缩放图像（内存优化版）
   237→    private func createScaledImage(from cgImage: CGImage, size: CGSize) -> CGImage {
   238→        autoreleasepool {
   239→            let colorSpace = CGColorSpaceCreateDeviceRGB()
   240→            
   241→            guard let context = CGContext(
   242→                data: nil,
   243→                width: Int(size.width),
   244→                height: Int(size.height),
   245→                bitsPerComponent: 8,
   246→                bytesPerRow: 0,
   247→                space: colorSpace,
   248→                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
   249→            ) else {
   250→                return cgImage
   251→            }
   252→            
   253→            context.interpolationQuality = .high
   254→            context.draw(cgImage, in: CGRect(origin: .zero, size: size))
   255→            
   256→            return context.makeImage() ?? cgImage
   257→        }
   258→    }
   259→    
   260→    // Core Graphics版本的底部文字相框渲染
   261→    private func renderBottomTextFrameCG(
   262→        context: CGContext,
   263→        imageSize: CGSize,
   264→        customText: String,
   265→        showDate: Bool,
   266→        showLocation: Bool,
   267→        showExif: Bool,
   268→        showExifParams: Bool,
   269→        showExifDate: Bool,
   270→        selectedLogo: String?,
   271→        showSignature: Bool,
   272→        metadata: [String: Any]
   273→    ) {
   274→        // 底部黑色条
   275→        let barHeight = imageSize.height * 0.08
   276→        let barRect = CGRect(x: 0, y: imageSize.height - barHeight, width: imageSize.width, height: barHeight)
   277→        
   278→        context.setFillColor(UIColor.black.cgColor)
   279→        context.fill(barRect)
   280→        
   281→        // 绘制自定义文字
   282→        if !customText.isEmpty {
   283→            let fontSize = barHeight * 0.4
   284→            let font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
   285→            
   286→            let textAttributes: [NSAttributedString.Key: Any] = [
   287→                .font: font,
   288→                .foregroundColor: UIColor.white
   289→            ]
   290→            
   291→            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   292→            let textSize = attributedString.size()
   293→            
   294→            let textRect = CGRect(
   295→                x: imageSize.width / 2 - textSize.width / 2,
   296→                y: imageSize.height - barHeight / 2 - textSize.height / 2,
   297→                width: textSize.width,
   298→                height: textSize.height
   299→            )
   300→            
   301→            // 使用Core Text绘制文字
   302→            let line = CTLineCreateWithAttributedString(attributedString)
   303→            context.saveGState()
   304→            context.textMatrix = .identity
   305→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   306→            context.scaleBy(x: 1, y: -1) // 翻转Y轴
   307→            CTLineDraw(line, context)
   308→            context.restoreGState()
   309→        }
   310→        
   311→        // 绘制日期
   312→        if showDate {
   313→            let dateFormatter = DateFormatter()
   314→            dateFormatter.dateFormat = "yyyy-MM-dd"
   315→            let dateString = dateFormatter.string(from: Date())
   316→            
   317→            let fontSize = barHeight * 0.3
   318→            let font = UIFont.systemFont(ofSize: fontSize, weight: .regular)
   319→            
   320→            let textAttributes: [NSAttributedString.Key: Any] = [
   321→                .font: font,
   322→                .foregroundColor: UIColor.white
   323→            ]
   324→            
   325→            let attributedString = NSAttributedString(string: dateString, attributes: textAttributes)
   326→            let textSize = attributedString.size()
   327→            
   328→            let textRect = CGRect(
   329→                x: imageSize.width - textSize.width - 20,
   330→                y: imageSize.height - barHeight / 2 - textSize.height / 2,
   331→                width: textSize.width,
   332→                height: textSize.height
   333→            )
   334→            
   335→            let line = CTLineCreateWithAttributedString(attributedString)
   336→            context.saveGState()
   337→            context.textMatrix = .identity
   338→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   339→            context.scaleBy(x: 1, y: -1)
   340→            CTLineDraw(line, context)
   341→            context.restoreGState()
   342→        }
   343→        
   344→        // 绘制Logo
   345→        if let logoName = selectedLogo {
   346→            let logoSize = barHeight * 0.7
   347→            if let logoImage = getOptimizedLogoImage(logoName, maxSize: logoSize) {
   348→                let logoRect = CGRect(
   349→                    x: 20,
   350→                    y: imageSize.height - barHeight / 2 - logoSize / 2,
   351→                    width: logoSize,
   352→                    height: logoSize
   353→                )
   354→                
   355→                context.draw(logoImage, in: logoRect)
   356→            }
   357→        }
   358→        
   359→        // 绘制EXIF信息
   360→        if showExif && showExifParams {
   361→            var exifText = ""
   362→            
   363→            if let exif = metadata["exif"] as? [String: Any] {
   364→                if let iso = exif[kCGImagePropertyExifISOSpeedRatings as String] as? [NSNumber], let isoValue = iso.first {
   365→                    exifText += "ISO \(isoValue) "
   366→                }
   367→                
   368→                if let aperture = exif[kCGImagePropertyExifFNumber as String] as? NSNumber {
   369→                    exifText += "f/\(aperture) "
   370→                }
   371→                
   372→                if let shutterSpeed = exif[kCGImagePropertyExifExposureTime as String] as? NSNumber {
   373→                    let shutterValue = 1.0 / shutterSpeed.doubleValue
   374→                    exifText += "1/\(Int(shutterValue))s "
   375→                }
   376→            }
   377→            
   378→            if !exifText.isEmpty {
   379→                let fontSize = barHeight * 0.25
   380→                let font = UIFont.systemFont(ofSize: fontSize, weight: .regular)
   381→                
   382→                let textAttributes: [NSAttributedString.Key: Any] = [
   383→                    .font: font,
   384→                    .foregroundColor: UIColor.white
   385→                ]
   386→                
   387→                let attributedString = NSAttributedString(string: exifText, attributes: textAttributes)
   388→                let textSize = attributedString.size()
   389→                
   390→                let textRect = CGRect(
   391→                    x: 20,
   392→                    y: imageSize.height - barHeight + 5,
   393→                    width: textSize.width,
   394→                    height: textSize.height
   395→                )
   396→                
   397→                let line = CTLineCreateWithAttributedString(attributedString)
   398→                context.saveGState()
   399→                context.textMatrix = .identity
   400→                context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   401→                context.scaleBy(x: 1, y: -1)
   402→                CTLineDraw(line, context)
   403→                context.restoreGState()
   404→            }
   405→        }
   406→    }
   407→    
   408→    // Core Graphics版本的中心水印渲染
   409→    private func renderCenterWatermarkFrameCG(
   410→        context: CGContext,
   411→        imageSize: CGSize,
   412→        customText: String,
   413→        selectedLogo: String?,
   414→        metadata: [String: Any]
   415→    ) {
   416→        // 绘制半透明Logo
   417→        if let logoName = selectedLogo {
   418→            let logoSize = min(imageSize.width, imageSize.height) * 0.2
   419→            if let logoImage = getOptimizedLogoImage(logoName, maxSize: logoSize) {
   420→                let logoRect = CGRect(
   421→                    x: imageSize.width / 2 - logoSize / 2,
   422→                    y: imageSize.height / 2 - logoSize / 2,
   423→                    width: logoSize,
   424→                    height: logoSize
   425→                )
   426→                
   427→                context.saveGState()
   428→                context.setAlpha(0.3)
   429→                context.draw(logoImage, in: logoRect)
   430→                context.restoreGState()
   431→            }
   432→        }
   433→        
   434→        // 绘制自定义文字
   435→        if !customText.isEmpty {
   436→            let fontSize = min(imageSize.width, imageSize.height) * 0.03
   437→            let font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
   438→            
   439→            let textAttributes: [NSAttributedString.Key: Any] = [
   440→                .font: font,
   441→                .foregroundColor: UIColor.white.withAlphaComponent(0.7)
   442→            ]
   443→            
   444→            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   445→            let textSize = attributedString.size()
   446→            
   447→            let textRect = CGRect(
   448→                x: imageSize.width / 2 - textSize.width / 2,
   449→                y: imageSize.height / 2 + min(imageSize.width, imageSize.height) * 0.12,
   450→                width: textSize.width,
   451→                height: textSize.height
   452→            )
   453→            
   454→            // 添加文字背景
   455→            let backgroundRect = textRect.insetBy(dx: -10, dy: -5)
   456→            context.setFillColor(UIColor.black.withAlphaComponent(0.3).cgColor)
   457→            context.fill(backgroundRect)
   458→            
   459→            // 绘制文字
   460→            let line = CTLineCreateWithAttributedString(attributedString)
   461→            context.saveGState()
   462→            context.textMatrix = .identity
   463→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   464→            context.scaleBy(x: 1, y: -1)
   465→            CTLineDraw(line, context)
   466→            context.restoreGState()
   467→        }
   468→    }
   469→    
   470→    // Core Graphics版本的杂志封面渲染
   471→    private func renderMagazineCoverFrameCG(
   472→        context: CGContext,
   473→        imageSize: CGSize,
   474→        customText: String,
   475→        showDate: Bool,
   476→        selectedLogo: String?,
   477→        metadata: [String: Any]
   478→    ) {
   479→        // 顶部黑色条
   480→        let topBarHeight = imageSize.height * 0.1
   481→        let topBarRect = CGRect(x: 0, y: 0, width: imageSize.width, height: topBarHeight)
   482→        context.setFillColor(UIColor.black.cgColor)
   483→        context.fill(topBarRect)
   484→        
   485→        // 底部黑色条
   486→        let bottomBarHeight = imageSize.height * 0.05
   487→        let bottomBarRect = CGRect(x: 0, y: imageSize.height - bottomBarHeight, width: imageSize.width, height: bottomBarHeight)
   488→        context.setFillColor(UIColor.black.cgColor)
   489→        context.fill(bottomBarRect)
   490→        
   491→        // 绘制Logo
   492→        if let logoName = selectedLogo {
   493→            let logoHeight = topBarHeight * 0.6
   494→            if let logoImage = getOptimizedLogoImage(logoName, maxSize: logoHeight) {
   495→                let logoWidth = logoHeight * (CGFloat(logoImage.width) / CGFloat(logoImage.height))
   496→                let logoRect = CGRect(
   497→                    x: 20,
   498→                    y: topBarHeight / 2 - logoHeight / 2,
   499→                    width: logoWidth,
   500→                    height: logoHeight
   501→                )
   502→                
   503→                context.draw(logoImage, in: logoRect)
   504→            }
   505→        }
   506→        
   507→        // 绘制标题
   508→        if !customText.isEmpty {
   509→            let fontSize = topBarHeight * 0.4
   510→            let font = UIFont.systemFont(ofSize: fontSize, weight: .bold)
   511→            
   512→            let textAttributes: [NSAttributedString.Key: Any] = [
   513→                .font: font,
   514→                .foregroundColor: UIColor.white
   515→            ]
   516→            
   517→            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   518→            let textSize = attributedString.size()
   519→            
   520→            let textRect = CGRect(
   521→                x: imageSize.width - textSize.width - 20,
   522→                y: topBarHeight / 2 - textSize.height / 2,
   523→                width: textSize.width,
   524→                height: textSize.height
   525→            )
   526→            
   527→            let line = CTLineCreateWithAttributedString(attributedString)
   528→            context.saveGState()
   529→            context.textMatrix = .identity
   530→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   531→            context.scaleBy(x: 1, y: -1)
   532→            CTLineDraw(line, context)
   533→            context.restoreGState()
   534→        }
   535→        
   536→        // 绘制日期
   537→        if showDate {
   538→            let dateFormatter = DateFormatter()
   539→            dateFormatter.dateFormat = "yyyy年MM月"
   540→            let dateString = dateFormatter.string(from: Date())
   541→            
   542→            let fontSize = bottomBarHeight * 0.6
   543→            let font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
   544→            
   545→            let textAttributes: [NSAttributedString.Key: Any] = [
   546→                .font: font,
   547→                .foregroundColor: UIColor.white
   548→            ]
   549→            
   550→            let attributedString = NSAttributedString(string: dateString, attributes: textAttributes)
   551→            let textSize = attributedString.size()
   552→            
   553→            let textRect = CGRect(
   554→                x: imageSize.width / 2 - textSize.width / 2,
   555→                y: imageSize.height - bottomBarHeight / 2 - textSize.height / 2,
   556→                width: textSize.width,
   557→                height: textSize.height
   558→            )
   559→            
   560→            let line = CTLineCreateWithAttributedString(attributedString)
   561→            context.saveGState()
   562→            context.textMatrix = .identity
   563→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   564→            context.scaleBy(x: 1, y: -1)
   565→            CTLineDraw(line, context)
   566→            context.restoreGState()
   567→        }
   568→    }
   569→    
   570→    // Core Graphics版本的宝丽来相框渲染
   571→    private func renderPolaroidFrameCG(
   572→        context: CGContext,
   573→        imageSize: CGSize,
   574→        customText: String,
   575→        showDate: Bool,
   576→        metadata: [String: Any]
   577→    ) {
   578→        // 计算宝丽来相框的尺寸和位置
   579→        let borderWidth: CGFloat = min(imageSize.width, imageSize.height) * 0.05
   580→        let bottomBorderHeight: CGFloat = min(imageSize.width, imageSize.height) * 0.15
   581→        
   582→        // 绘制白色背景框
   583→        let frameRect = CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height)
   584→        context.setFillColor(UIColor.white.cgColor)
   585→        context.fill(frameRect)
   586→        
   587→        // 绘制照片区域阴影效果
   588→        let photoRect = CGRect(
   589→            x: borderWidth,
   590→            y: borderWidth,
   591→            width: imageSize.width - borderWidth * 2,
   592→            height: imageSize.height - borderWidth - bottomBorderHeight
   593→        )
   594→        
   595→        context.setFillColor(UIColor.black.withAlphaComponent(0.1).cgColor)
   596→        context.fill(photoRect)
   597→        
   598→        // 绘制自定义文字
   599→        if !customText.isEmpty {
   600→            let fontSize = bottomBorderHeight * 0.4
   601→            let font = UIFont(name: "Marker Felt", size: fontSize) ?? UIFont.systemFont(ofSize: fontSize, weight: .medium)
   602→            
   603→            let textAttributes: [NSAttributedString.Key: Any] = [
   604→                .font: font,
   605→                .foregroundColor: UIColor.black
   606→            ]
   607→            
   608→            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   609→            let textSize = attributedString.size()
   610→            
   611→            let textRect = CGRect(
   612→                x: imageSize.width / 2 - textSize.width / 2,
   613→                y: imageSize.height - bottomBorderHeight / 2 - textSize.height / 2,
   614→                width: textSize.width,
   615→                height: textSize.height
   616→            )
   617→            
   618→            let line = CTLineCreateWithAttributedString(attributedString)
   619→            context.saveGState()
   620→            context.textMatrix = .identity
   621→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   622→            context.scaleBy(x: 1, y: -1)
   623→            CTLineDraw(line, context)
   624→            context.restoreGState()
   625→        }
   626→        
   627→        // 绘制日期
   628→        if showDate {
   629→            let dateFormatter = DateFormatter()
   630→            dateFormatter.dateFormat = "yyyy.MM.dd"
   631→            let dateString = dateFormatter.string(from: Date())
   632→            
   633→            let fontSize = bottomBorderHeight * 0.25
   634→            let font = UIFont(name: "Marker Felt", size: fontSize) ?? UIFont.systemFont(ofSize: fontSize, weight: .light)
   635→            
   636→            let textAttributes: [NSAttributedString.Key: Any] = [
   637→                .font: font,
   638→                .foregroundColor: UIColor.black.withAlphaComponent(0.6)
   639→            ]
   640→            
   641→            let attributedString = NSAttributedString(string: dateString, attributes: textAttributes)
   642→            let textSize = attributedString.size()
   643→            
   644→            let textRect = CGRect(
   645→                x: imageSize.width - textSize.width - borderWidth,
   646→                y: imageSize.height - textSize.height - borderWidth * 0.5,
   647→                width: textSize.width,
   648→                height: textSize.height
   649→            )
   650→            
   651→            let line = CTLineCreateWithAttributedString(attributedString)
   652→            context.saveGState()
   653→            context.textMatrix = .identity
   654→            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   655→            context.scaleBy(x: 1, y: -1)
   656→            CTLineDraw(line, context)
   657→            context.restoreGState()
   658→        }
   659→    }
   660→    
   661→    // 优化的Logo图像获取（内存优化）
   662→    private func getOptimizedLogoImage(_ logoName: String, maxSize: CGFloat) -> CGImage? {
   663→        guard let logoImage = UIImage(named: logoName)?.cgImage else { return nil }
   664→        
   665→        let originalWidth = CGFloat(logoImage.width)
   666→        let originalHeight = CGFloat(logoImage.height)
   667→        let maxDimension = max(originalWidth, originalHeight)
   668→        
   669→        // 如果Logo已经很小，直接返回
   670→        if maxDimension <= maxSize * 2 {
   671→            return logoImage
   672→        }
   673→        
   674→        // 计算新尺寸
   675→        let scale = (maxSize * 2) / maxDimension
   676→        let newSize = CGSize(width: originalWidth * scale, height: originalHeight * scale)
   677→        
   678→        // 使用Core Graphics缩放
   679→        return createScaledImage(from: logoImage, size: newSize)
   680→    }
   681→}
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Glob**

Result:

```
/Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryMonitor.swift
/Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryPressureManager.swift
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Core/Utils/MemoryMonitor.swift`

Result:

```
1→import Foundation
     2→import os.log
     3→
     4→class MemoryMonitor {
     5→    static let shared = MemoryMonitor()
     6→    private let logger = Logger(subsystem: "MCCamera", category: "Memory")
     7→    
     8→    private init() {}
     9→    
    10→    // 获取当前内存使用情况
    11→    func getCurrentMemoryUsage() -> (used: Int64, available: Int64) {
    12→        var info = mach_task_basic_info()
    13→        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
    14→        
    15→        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
    16→            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
    17→                task_info(mach_task_self_,
    18→                         task_flavor_t(MACH_TASK_BASIC_INFO),
    19→                         $0,
    20→                         &count)
    21→            }
    22→        }
    23→        
    24→        if kerr == KERN_SUCCESS {
    25→            let usedMemory = Int64(info.resident_size)
    26→            let totalMemory = Int64(ProcessInfo.processInfo.physicalMemory)
    27→            return (used: usedMemory, available: totalMemory - usedMemory)
    28→        } else {
    29→            return (used: 0, available: 0)
    30→        }
    31→    }
    32→    
    33→    // 格式化内存大小显示
    34→    func formatMemorySize(_ bytes: Int64) -> String {
    35→        let formatter = ByteCountFormatter()
    36→        formatter.allowedUnits = [.useMB, .useGB]
    37→        formatter.countStyle = .memory
    38→        return formatter.string(fromByteCount: bytes)
    39→    }
    40→    
    41→    // 记录内存使用情况
    42→    func logMemoryUsage(context: String) {
    43→        let memory = getCurrentMemoryUsage()
    44→        let usedMB = memory.used / 1024 / 1024
    45→        let availableMB = memory.available / 1024 / 1024
    46→        
    47→        let message = "\(context) - 已使用: \(usedMB)MB, 可用: \(availableMB)MB"
    48→        logger.info("\(message, privacy: .public)")
    49→        print("🧠 \(message)")
    50→        
    51→        // 内存警告阈值检查
    52→        if usedMB > 300 {
    53→            logger.warning("内存使用过高: \(usedMB, privacy: .public)MB")
    54→            print("⚠️ 内存使用过高: \(usedMB)MB")
    55→        }
    56→    }
    57→    
    58→    // 检查是否应该触发内存清理
    59→    func shouldTriggerMemoryCleanup() -> Bool {
    60→        let memory = getCurrentMemoryUsage()
    61→        let usedMB = memory.used / 1024 / 1024
    62→        return usedMB > 250 // 超过250MB触发清理
    63→    }
    64→    
    65→    // 强制内存清理
    66→    func forceMemoryCleanup() {
    67→        autoreleasepool {
    68→            // 触发自动释放池清理
    69→        }
    70→        
    71→        // 建议系统进行内存回收
    72→        if #available(iOS 13.0, *) {
    73→            // iOS 13+ 可以使用更现代的内存管理
    74→        }
    75→        
    76→        logger.info("执行内存清理")
    77→        print("🧹 执行内存清理")
    78→    }
    79→}
    80→
    81→// 扩展以支持内存监控的自动释放池
    82→extension NSObject {
    83→    func withMemoryMonitoring<T>(context: String, _ closure: () throws -> T) rethrows -> T {
    84→        MemoryMonitor.shared.logMemoryUsage(context: "\(context) - 开始")
    85→        
    86→        defer {
    87→            MemoryMonitor.shared.logMemoryUsage(context: "\(context) - 结束")
    88→            
    89→            if MemoryMonitor.shared.shouldTriggerMemoryCleanup() {
    90→                MemoryMonitor.shared.forceMemoryCleanup()
    91→            }
    92→        }
    93→        
    94→        return try autoreleasepool {
    95→            return try closure()
    96→        }
    97→    }
    98→}
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Core/Utils/MemoryPressureManager.swift`

Result:

```
1→import Foundation
     2→import UIKit
     3→import os.log
     4→
     5→class MemoryPressureManager: NSObject {
     6→    static let shared = MemoryPressureManager()
     7→    
     8→    private let logger = Logger(subsystem: "MCCamera", category: "MemoryPressure")
     9→    private var isHandlingMemoryWarning = false
    10→    
    11→    // 内存压力阈值 (MB)
    12→    private let criticalMemoryThreshold: Int64 = 200 // 200MB
    13→    private let warningMemoryThreshold: Int64 = 150  // 150MB
    14→    
    15→    override init() {
    16→        super.init()
    17→        setupMemoryWarningNotifications()
    18→    }
    19→    
    20→    deinit {
    21→        NotificationCenter.default.removeObserver(self)
    22→    }
    23→    
    24→    private func setupMemoryWarningNotifications() {
    25→        NotificationCenter.default.addObserver(
    26→            self,
    27→            selector: #selector(handleMemoryWarning),
    28→            name: UIApplication.didReceiveMemoryWarningNotification,
    29→            object: nil
    30→        )
    31→    }
    32→    
    33→    @objc private func handleMemoryWarning() {
    34→        guard !isHandlingMemoryWarning else { return }
    35→        
    36→        isHandlingMemoryWarning = true
    37→        logger.critical("🚨 收到系统内存警告")
    38→        
    39→        DispatchQueue.global(qos: .utility).async { [weak self] in
    40→            self?.performAggressiveMemoryCleanup()
    41→            
    42→            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
    43→                self?.isHandlingMemoryWarning = false
    44→            }
    45→        }
    46→    }
    47→    
    48→    // 激进的内存清理
    49→    private func performAggressiveMemoryCleanup() {
    50→        logger.info("执行激进内存清理")
    51→        
    52→        // 1. 强制执行多轮垃圾回收
    53→        for i in 0..<3 {
    54→            autoreleasepool {
    55→                // 触发自动释放池清理
    56→                logger.debug("执行垃圾回收轮次 \(i + 1)")
    57→            }
    58→        }
    59→        
    60→        // 2. 清理URLCache
    61→        URLCache.shared.removeAllCachedResponses()
    62→        
    63→        // 3. 建议系统回收内存
    64→        if #available(iOS 13.0, *) {
    65→            // 现代内存管理
    66→        } else {
    67→            // 兼容老版本
    68→        }
    69→        
    70→        // 4. 记录清理后的内存状态
    71→        let afterMemory = MemoryMonitor.shared.getCurrentMemoryUsage()
    72→        logger.info("内存清理完成，当前使用: \(afterMemory.used / 1024 / 1024)MB")
    73→    }
    74→    
    75→    // 检查内存压力级别
    76→    func checkMemoryPressure() -> MemoryPressureLevel {
    77→        let memory = MemoryMonitor.shared.getCurrentMemoryUsage()
    78→        let usedMB = memory.used / 1024 / 1024
    79→        
    80→        if usedMB >= criticalMemoryThreshold {
    81→            logger.warning("内存压力：危险 (\(usedMB)MB)")
    82→            return .critical
    83→        } else if usedMB >= warningMemoryThreshold {
    84→            logger.info("内存压力：警告 (\(usedMB)MB)")
    85→            return .warning
    86→        } else {
    87→            return .normal
    88→        }
    89→    }
    90→    
    91→    // 根据内存压力调整处理策略
    92→    func getOptimalProcessingStrategy() -> ImageProcessingStrategy {
    93→        let pressureLevel = checkMemoryPressure()
    94→        
    95→        switch pressureLevel {
    96→        case .critical:
    97→            logger.warning("采用极端内存优化策略")
    98→            return .ultraLowMemory
    99→        case .warning:
   100→            logger.info("采用低内存优化策略")
   101→            return .lowMemory
   102→        case .normal:
   103→            return .standard
   104→        }
   105→    }
   106→    
   107→    // 预防性内存清理
   108→    func performPreventiveCleanup() {
   109→        let pressureLevel = checkMemoryPressure()
   110→        
   111→        if pressureLevel != .normal {
   112→            logger.info("执行预防性内存清理")
   113→            autoreleasepool {
   114→                // 轻量级清理
   115→            }
   116→        }
   117→    }
   118→}
   119→
   120→// 内存压力级别
   121→enum MemoryPressureLevel {
   122→    case normal
   123→    case warning
   124→    case critical
   125→}
   126→
   127→// 图像处理策略
   128→enum ImageProcessingStrategy {
   129→    case standard      // 标准处理：正常质量
   130→    case lowMemory     // 低内存模式：适度压缩
   131→    case ultraLowMemory // 极低内存模式：激进压缩
   132→    
   133→    var maxPixels: Int {
   134→        switch self {
   135→        case .standard:
   136→            return 25_000_000  // 25MP
   137→        case .lowMemory:
   138→            return 12_000_000  // 12MP
   139→        case .ultraLowMemory:
   140→            return 6_000_000   // 6MP
   141→        }
   142→    }
   143→    
   144→    var compressionQuality: CGFloat {
   145→        switch self {
   146→        case .standard:
   147→            return 0.9
   148→        case .lowMemory:
   149→            return 0.8
   150→        case .ultraLowMemory:
   151→            return 0.7
   152→        }
   153→    }
   154→}
```

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] 🌡️ Analyze PhotoProcessor.swift for memory issues
- [X] 🌡️ Check PhotoDecorationService.swift for memory leaks
- [⚡] 🌡️ Review camera capture flow for proper memory management
- [ ] 🌡️ Implement image memory optimization techniques
- [ ] 🌡️ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

Based on my analysis of the codebase, I've identified several critical memory issues that are likely causing the app to crash. Here are the key problems and my recommendations:

## Critical Memory Issues Found:

### 1. **Excessive Memory Usage in Photo Processing**
- The app is attempting to process 48MP images (8064×6048) directly in memory
- Each 48MP image requires ~300MB+ of RAM when decompressed
- Multiple image copies are created during processing without proper cleanup

### 2. **Missing Memory Pressure Handling**
- While you have monitoring code, the critical thresholds are too high (200MB threshold on iOS 14 device is too late)
- The app doesn't properly abort operations when memory is critically low

### 3. **CGImage Memory Leaks**
- Creating multiple CGImage instances without immediate release
- Core Graphics contexts not being properly managed

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] 🌡️ Analyze PhotoProcessor.swift for memory issues
- [X] 🌡️ Check PhotoDecorationService.swift for memory leaks
- [X] 🌡️ Review camera capture flow for proper memory management
- [⚡] 🌡️ Implement image memory optimization techniques
- [ ] 🌡️ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

## Immediate Memory Optimizations:

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Core/Utils/MemoryPressureManager.swift`

Result:

```
Applied 3 edits to /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryPressureManager.swift:
1. Replaced "    // 内存压力阈值 (MB)
    private let criticalMemoryT..." with "    // 内存压力阈值 (MB) - 针对iOS 14设备优化
    private let ..."
2. Replaced "    var maxPixels: Int {
        switch self {
   ..." with "    var maxPixels: Int {
        switch self {
   ..."
3. Replaced "    var compressionQuality: CGFloat {
        swit..." with "    var compressionQuality: CGFloat {
        swit..."
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Core/Utils/MemoryMonitor.swift`

Result:

```
Applied 2 edits to /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryMonitor.swift:
1. Replaced "        // 内存警告阈值检查
        if usedMB > 300 {
    ..." with "        // 内存警告阈值检查 - 针对iOS 14设备优化
        if used..."
2. Replaced "    // 检查是否应该触发内存清理
    func shouldTriggerMemoryCl..." with "    // 检查是否应该触发内存清理 - 更积极的策略
    func shouldTrigge..."
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Core/Photo/PhotoProcessor.swift`

Error:

```
<tool_use_error>String to replace not found in file.
String:             // 在低光环境下，系统可能会自动回退到 12MP 以获得更好的画质，这是硬件和系统层面的优化。
性能: 拍摄和处理 48MP 照片耗时更长，需要做好 UI 反馈（如加载指示器）。
ProRAW vs HEIF Max: 两者通常是互斥的。HEIF Max 是经过苹果图像管线处理的高分辨率照片，而 ProRAW 是未经处理的原始传感器数据。</tool_use_error>
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     9→    init(locationManager: LocationManager) {
    10→        self.locationManager = locationManager
    11→    }
    12→    
    13→    func savePhotoToLibrary(_ imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio? = nil, frameSettings: FrameSettings? = nil) {
    14→        // 立即检查内存状态
    15→        MemoryMonitor.shared.logMemoryUsage(context: "保存照片开始")
    16→        
    17→        // 如果内存危险，立即使用最简保存策略
    18→        if MemoryMonitor.shared.shouldAbortOperation() {
    19→            print("🚨 内存不足，使用紧急保存模式")
    20→            saveEmergencyMode(imageData)
    21→            return
    22→        }
    23→        
    24→        PHPhotoLibrary.requestAuthorization { [weak self] status in
    25→            guard status == .authorized else {
    26→                print("❌ 相册权限未授权")
    27→                return
    28→            }
    29→            
    30→            // 检查是否为超大图像，如果是则使用最简保存策略
    31→            if let self = self, self.isUltraLargeImage(imageData) {
    32→                print("🚨 检测到超大图像，使用紧急保存模式")
    33→                self.saveUltraLargeImageDirectly(imageData)
    34→                return
    35→            }
    36→            
    37→            // 使用autoreleasepool减少内存占用
    38→            autoreleasepool {
    39→                // 先检查原始数据是否包含完整元数据
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    58→            }
    59→        }
    60→    }
    61→    
    62→    // 紧急模式保存 - 内存不足时使用
    63→    private func saveEmergencyMode(_ imageData: Data) {
    64→        PHPhotoLibrary.shared().performChanges({
    65→            let creationRequest = PHAssetCreationRequest.forAsset()
    66→            creationRequest.addResource(with: .photo, data: imageData, options: nil)
    67→        }) { success, error in
    68→            if success {
    69→                print("✅ 紧急模式保存成功")
    70→            } else {
    71→                print("❌ 紧急模式保存失败: \(error?.localizedDescription ?? "未知错误")")
    72→            }
    73→        }
    74→    }
    75→    
    76→    // 检查是否为超大图像 - 降低阈值
    77→    private func isUltraLargeImage(_ imageData: Data) -> Bool {
    78→        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
    79→              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
    80→              let width = properties[kCGImagePropertyPixelWidth as String] as? Int,
    81→              let height = properties[kCGImagePropertyPixelHeight as String] as? Int else {
    82→            return false
    83→        }
    84→        
    85→        let megapixels = (width * height) / 1_000_000
    86→        return megapixels >= 15 // 15MP以上认为是超大图像 (降低阈值)
    87→    }
    88→    
    89→    // 超大图像直接保存（零处理）
    90→    private func saveUltraLargeImageDirectly(_ imageData: Data) {
    91→        PHPhotoLibrary.shared().performChanges({
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   159→            print("  - 高度: \(originalHeight)")
   160→            print("  - 总像素: \(originalMegapixels)MP")
   161→            print("  - 是否为48MP: \(originalMegapixels >= 40)")
   162→            
   163→            // 关键优化：立即检查内存状态
   164→            if MemoryMonitor.shared.shouldAbortOperation() {
   165→                print("🚨 内存不足，终止复杂处理")
   166→                resultData = imageData // 直接返回原始数据
   167→                return
   168→            }
   169→            
   170→            // 🚨 大图像特殊处理：避免内存爆炸 - 降低阈值
   171→            if originalMegapixels >= 20 {
   172→                print("🚨 检测到大图像(\(originalMegapixels)MP)！启用极简处理模式")
   173→                resultData = handleUltraHighResolutionImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   174→                return
   175→            } else if originalMegapixels >= 8 {
   176→                print("⚡ 检测到中尺寸图像，启用优化处理")
   177→                resultData = handleLargeImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   178→                return
   179→            }
   180→            
   181→            print("✅ 标准图像，使用常规处理")
   182→            
   183→            // 常规图像处理（小于20MP）
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   353→        // 检查当前内存压力
   354→        let memoryUsage = MemoryMonitor.shared.getCurrentMemoryUsage()
   355→        let usedMB = memoryUsage.used / 1024 / 1024
   356→        
   357→        // 如果内存压力极大，直接返回原始数据 - 更积极的策略
   358→        if usedMB > 100 {
   359→            print("🚨 内存压力过大(\(usedMB)MB)，直接保存原始数据")
   360→            return imageData
   361→        }
   362→        
   363→        // 如果没有裁剪需求且格式匹配，直接返回原始数据
   364→        if aspectRatio == nil || aspectRatio == .ratio4_3 {
   365→            print("🚀 无需处理，直接保存原始48MP数据")
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   408→        print("✅ 48MP最小化处理完成")
   409→        return mutableData as Data
   410→    }
   411→    
   412→    // 大图像优化处理（8-20MP）
   413→    private func handleLargeImage(source: CGImageSource, imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio?) -> Data {
   414→        print("⚡ 大图像优化处理")
   415→        
   416→        // 使用降采样技术，避免将完整图像加载到内存
   417→        let maxPixelSize = 2000 // 更保守的限制 - 2000px
   418→        
   419→        let options: [CFString: Any] = [
   420→            kCGImageSourceCreateThumbnailFromImageAlways: true,
   421→            kCGImageSourceCreateThumbnailWithTransform: true,
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Features/Frame/Services/PhotoDecorationService.swift`

Error:

```
<tool_use_error>String to replace not found in file.
String:         // 创建内存优化的UIImage - 极端优化版本
    private func createOptimizedUIImage(from imageData: Data, pixelCount: Int) -> UIImage? {
        // 更激进的内存控制策略
        if pixelCount > 48_000_000 { // 48MP - 极端压缩
            print("🚨 检测到48MP图像，启用极端内存优化")
            return createUltraDownsampledImage(from: imageData, maxPixels: 8_000_000) // 降至8MP
        } else if pixelCount > 20_000_000 { // 20MP+ - 激进压缩
            print("⚡ 检测到大图像，启用激进内存优化")
            return createDownsampledImage(from: imageData, maxPixels: 12_000_000) // 降至12MP
        } else if pixelCount > 10_000_000 { // 10MP+ - 适度压缩
            return createDownsampledImage(from: imageData, maxPixels: 8_000_000) // 降至8MP
        } else {
            // 小图像直接创建
            return UIImage(data: imageData)
        }
    }</tool_use_error>
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Features/Frame/Services/PhotoDecorationService.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   133→            return createOptimizedUIImage(from: imageData, pixelCount: pixelCount)
   134→        }
   135→    }
   136→    
   137→    // 创建内存优化的UIImage - 极端优化版本
   138→    private func createOptimizedUIImage(from imageData: Data, pixelCount: Int) -> UIImage? {
   139→        // 立即检查内存状态
   140→        if MemoryMonitor.shared.shouldAbortOperation() {
   141→            print("🚨 内存危险，使用最小降采样")
   142→            return createUltraDownsampledImage(from: imageData, maxPixels: 1_000_000) // 1MP
   143→        }
   144→        
   145→        // 更激进的内存控制策略 - 大幅降低阈值
   146→        if pixelCount > 20_000_000 { // 20MP+ - 极端压缩
   147→            print("🚨 检测到超大图像，启用极端内存优化")
   148→            return createUltraDownsampledImage(from: imageData, maxPixels: 3_000_000) // 降至3MP
   149→        } else if pixelCount > 8_000_000 { // 8MP+ - 激进压缩
   150→            print("⚡ 检测到大图像，启用激进内存优化")
   151→            return createDownsampledImage(from: imageData, maxPixels: 4_000_000) // 降至4MP
   152→        } else if pixelCount > 4_000_000 { // 4MP+ - 适度压缩
   153→            return createDownsampledImage(from: imageData, maxPixels: 3_000_000) // 降至3MP
   154→        } else {
   155→            // 小图像直接创建
   156→            return UIImage(data: imageData)
   157→        }
   158→    }
   159→    
   160→    // 极端降采样图像（用于48MP等超大图像）
   161→    private func createUltraDownsampledImage(from imageData: Data, maxPixels: Int) -> UIImage? {
   162→        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Features/Frame/Services/OptimizedPhotoDecorationRenderer.swift`

Result:

```
Applied 2 edits to /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Features/Frame/Services/OptimizedPhotoDecorationRenderer.swift:
1. Replaced "    // 内存优化配置 - 更激进的设置
    private let maxRenderSi..." with "    // 内存优化配置 - 极端保守的设置
    private let maxRenderS..."
2. Replaced "            // 计算缩放因子 - 更激进的缩小策略
            let t..." with "            // 计算缩放因子 - 极端激进的缩小策略
            let ..."
```

_**Agent (claude-sonnet-4-20250514)**_

Now let me add an important enhancement to handle memory warnings in real-time:

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   325→            
   326→            // 先设置属性，再添加图像
   327→            CGImageDestinationSetProperties(destination, options as CFDictionary)
   328→            
   329→            // 在添加图像之前再次检查内存
   330→            if MemoryMonitor.shared.shouldAbortOperation() {
   331→                print("🚨 处理过程中内存不足，返回原始数据")
   332→                resultData = imageData
   333→                return
   334→            }
   335→            
   336→            // 添加图像和元数据
   337→            CGImageDestinationAddImage(destination, processedCGImage, metadata as CFDictionary)
   338→            
   339→            // 完成写入
   340→            guard CGImageDestinationFinalize(destination) else {
   341→                print("❌ 无法完成图像写入")
   342→                resultData = imageData
   343→                return
   344→            }
   345→            
   346→            // 验证保存的元数据
   347→            verifyMetadata(mutableData)
   348→
```

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] 🌡️ Analyze PhotoProcessor.swift for memory issues
- [X] 🌡️ Check PhotoDecorationService.swift for memory leaks
- [X] 🌡️ Review camera capture flow for proper memory management
- [X] 🌡️ Implement image memory optimization techniques
- [ ] 🌡️ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

## 内存优化总结

我已经完成了对你的相机应用的全面内存优化，主要针对以下关键问题：

### 🔧 **核心优化措施:**

1. **降低内存阈值** - 从300MB调整为100MB危险线，80MB触发清理
2. **更激进的图像压缩** - 大幅降低处理像素上限和压缩质量
3. **紧急保存模式** - 内存不足时直接保存原图，跳过所有处理
4. **实时内存检查** - 在处理过程中多次检查内存状态
5. **降低触发阈值** - 15MP以上就认为是超大图像（原40MP）

### 📊 **具体数值优化:**

- **像素限制**: 标准模式从25MP→8MP，低内存4MP，极端2MP
- **内存阈值**: 危险线从200MB→120MB，警告从150MB→80MB  
- **渲染尺寸**: 从1536px→1200px，缩放限制从50%→30%
- **压缩质量**: 标准0.9→0.75，低内存0.65，极端0.5

### ⚡ **关键改进:**
- 添加了紧急模式保存，内存危险时零处理直接保存
- 处理过程中多点内存检查，可随时中止避免崩溃
- 对iOS 14设备的内存限制进行了专门优化

现在请测试应用，特别是拍摄大尺寸照片时的内存表现。如果仍有问题，我可以进一步降低阈值或添加更多保护措施。

