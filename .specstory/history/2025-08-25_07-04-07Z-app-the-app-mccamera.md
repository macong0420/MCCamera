<!-- Generated by SpecStory -->

# 48MP Photo Memory Optimization in Swift (2025-08-25 07:04:07Z)

<!-- Claude Code Session e8cf9288-bda4-4bfa-9297-1d0f935ceb2c (2025-08-25_07-04-07Z) -->

_**User**_

ç°åœ¨é¡¹ç›®æ‹ç…§å,å†…å­˜ä¼šçˆ†ç‚¸,å¯¼è‡´ app è¢«æ€æ­».The app â€œMCCameraâ€ has been killed by the operating system because it is using too much memory.
Domain: IDEDebugSessionErrorDomain
Code: 11
Recovery Suggestion: Use a memory profiling tool to track the process memory usage.
User Info: {
    DVTErrorCreationDateKey = "2025-08-25 07:02:35 +0000";
    IDERunOperationFailingWorker = DBGLLDBLauncher;
}
--

Event Metadata: com.apple.dt.IDERunOperationWorkerFinished : {
    "device_identifier" = "00008101-000354490C90001E";
    "device_model" = "iPhone13,1";
    "device_osBuild" = "14.2.1 (18B121)";
    "device_platform" = "com.apple.platform.iphoneos";
    "device_thinningType" = "iPhone13,1";
    "dvt_coredevice_version" = "397.28";
    "dvt_coresimulator_version" = "993.7";
    "dvt_mobiledevice_version" = "1759.60.7";
    "launchSession_schemeCommand" = Run;
    "launchSession_state" = 2;
    "launchSession_targetArch" = arm64;
    "operation_duration_ms" = 17935;
    "operation_errorCode" = 11;
    "operation_errorDomain" = IDEDebugSessionErrorDomain;
    "operation_errorWorker" = DBGLLDBLauncher;
    "operation_name" = IDEiPhoneRunOperationWorkerGroup;
    "param_debugger_attachToExtensions" = 0;
    "param_debugger_attachToXPC" = 1;
    "param_debugger_type" = 5;
    "param_destination_isProxy" = 0;
    "param_destination_platform" = "com.apple.platform.iphoneos";
    "param_diag_113575882_enable" = 0;
    "param_diag_MainThreadChecker_stopOnIssue" = 0;
    "param_diag_MallocStackLogging_enableDuringAttach" = 0;
    "param_diag_MallocStackLogging_enableForXPC" = 1;
    "param_diag_allowLocationSimulation" = 1;
    "param_diag_checker_tpc_enable" = 1;
    "param_diag_gpu_frameCapture_enable" = 0;
    "param_diag_gpu_shaderValidation_enable" = 0;
    "param_diag_gpu_validation_enable" = 0;
    "param_diag_guardMalloc_enable" = 0;
    "param_diag_memoryGraphOnResourceException" = 0;
    "param_diag_mtc_enable" = 1;
    "param_diag_queueDebugging_enable" = 1;
    "param_diag_runtimeProfile_generate" = 0;
    "param_diag_sanitizer_asan_enable" = 0;
    "param_diag_sanitizer_tsan_enable" = 0;
    "param_diag_sanitizer_tsan_stopOnIssue" = 0;
    "param_diag_sanitizer_ubsan_enable" = 0;
    "param_diag_sanitizer_ubsan_stopOnIssue" = 0;
    "param_diag_showNonLocalizedStrings" = 0;
    "param_diag_viewDebugging_enabled" = 1;
    "param_diag_viewDebugging_insertDylibOnLaunch" = 1;
    "param_install_style" = 2;
    "param_launcher_UID" = 2;
    "param_launcher_allowDeviceSensorReplayData" = 0;
    "param_launcher_kind" = 0;
    "param_launcher_style" = 0;
    "param_launcher_substyle" = 0;
    "param_runnable_appExtensionHostRunMode" = 0;
    "param_runnable_productType" = "com.apple.product-type.application";
    "param_structuredConsoleMode" = 1;
    "param_testing_launchedForTesting" = 0;
    "param_testing_suppressSimulatorApp" = 0;
    "param_testing_usingCLI" = 0;
    "sdk_canonicalName" = "iphoneos18.2";
    "sdk_osVersion" = "18.2";
    "sdk_variant" = iphoneos;
}
--


System Information

macOS Version 15.2 (Build 24C103)
Xcode 16.2 (23507) (Build 16C5032a)
Timestamp: 2025-08-25T15:02:35+08:00è¿™é‡Œæœ‰æ—¥å¿—.ç»“åˆæ—¥å¿—è¿›è¡Œå†…å­˜çš„ä¼˜åŒ–.æ³¨æ„éƒ½æ²¡æœ‰æ·»åŠ ç›¸æ¡†å’Œæ°´å°å°±è§¦å‘äº†å†…å­˜çˆ†ç‚¸

---

_**Agent (claude-sonnet-4-20250514)**_

I'll help you optimize the memory usage in your camera app. Let me start by analyzing the current code to identify potential memory leaks and inefficient memory usage patterns.

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [ ] ğŸŒ¡ï¸ Analyze PhotoProcessor.swift for memory issues
- [ ] ğŸŒ¡ï¸ Check PhotoDecorationService.swift for memory leaks
- [ ] ğŸŒ¡ï¸ Review camera capture flow for proper memory management
- [ ] ğŸŒ¡ï¸ Implement image memory optimization techniques
- [ ] ğŸŒ¡ï¸ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [âš¡] ğŸŒ¡ï¸ Analyze PhotoProcessor.swift for memory issues
- [ ] ğŸŒ¡ï¸ Check PhotoDecorationService.swift for memory leaks
- [ ] ğŸŒ¡ï¸ Review camera capture flow for proper memory management
- [ ] ğŸŒ¡ï¸ Implement image memory optimization techniques
- [ ] ğŸŒ¡ï¸ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Core/Photo/PhotoProcessor.swift`

Result:

```
1â†’import UIKit
     2â†’import ImageIO
     3â†’import Photos
     4â†’import UniformTypeIdentifiers
     5â†’
     6â†’class PhotoProcessor {
     7â†’    private let locationManager: LocationManager
     8â†’    
     9â†’    init(locationManager: LocationManager) {
    10â†’        self.locationManager = locationManager
    11â†’    }
    12â†’    
    13â†’    func savePhotoToLibrary(_ imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio? = nil, frameSettings: FrameSettings? = nil) {
    14â†’        PHPhotoLibrary.requestAuthorization { [weak self] status in
    15â†’            guard status == .authorized else {
    16â†’                print("âŒ ç›¸å†Œæƒé™æœªæˆæƒ")
    17â†’                return
    18â†’            }
    19â†’            
    20â†’            // æ£€æŸ¥æ˜¯å¦ä¸ºè¶…å¤§å›¾åƒï¼Œå¦‚æœæ˜¯åˆ™ä½¿ç”¨æœ€ç®€ä¿å­˜ç­–ç•¥
    21â†’            if let self = self, self.isUltraLargeImage(imageData) {
    22â†’                print("ğŸš¨ æ£€æµ‹åˆ°è¶…å¤§å›¾åƒï¼Œä½¿ç”¨ç´§æ€¥ä¿å­˜æ¨¡å¼")
    23â†’                self.saveUltraLargeImageDirectly(imageData)
    24â†’                return
    25â†’            }
    26â†’            
    27â†’            // ä½¿ç”¨autoreleasepoolå‡å°‘å†…å­˜å ç”¨
    28â†’            autoreleasepool {
    29â†’                // å…ˆæ£€æŸ¥åŸå§‹æ•°æ®æ˜¯å¦åŒ…å«å®Œæ•´å…ƒæ•°æ®
    30â†’                self?.logOriginalMetadata(imageData)
    31â†’                
    32â†’                // åº”ç”¨ç›¸æ¡†ï¼ˆå¦‚æœè®¾ç½®äº†ï¼‰
    33â†’                var processedImageData = imageData
    34â†’                if let frameSettings = frameSettings, frameSettings.selectedFrame != .none {
    35â†’                    let photoDecorationService = PhotoDecorationService(frameSettings: frameSettings)
    36â†’                    processedImageData = photoDecorationService.applyFrameToPhoto(imageData)
    37â†’                    print("âœ… å·²åº”ç”¨ç›¸æ¡†: \(frameSettings.selectedFrame.rawValue)")
    38â†’                }
    39â†’                
    40â†’                // åˆ›å»ºå¸¦æœ‰å®Œæ•´å…ƒæ•°æ®çš„å›¾åƒæ•°æ®
    41â†’                guard let enhancedImageData = self?.createImageWithCompleteMetadata(from: processedImageData, format: format, aspectRatio: aspectRatio) else {
    42â†’                    print("âŒ æ— æ³•åˆ›å»ºå¸¦æœ‰å®Œæ•´å…ƒæ•°æ®çš„å›¾åƒ")
    43â†’                    return
    44â†’                }
    45â†’                
    46â†’                // ä¿å­˜åˆ°ç›¸å†Œ
    47â†’                self?.saveImageDataToPhotoLibrary(enhancedImageData)
    48â†’            }
    49â†’        }
    50â†’    }
    51â†’    
    52â†’    // æ£€æŸ¥æ˜¯å¦ä¸ºè¶…å¤§å›¾åƒ
    53â†’    private func isUltraLargeImage(_ imageData: Data) -> Bool {
    54â†’        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
    55â†’              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
    56â†’              let width = properties[kCGImagePropertyPixelWidth as String] as? Int,
    57â†’              let height = properties[kCGImagePropertyPixelHeight as String] as? Int else {
    58â†’            return false
    59â†’        }
    60â†’        
    61â†’        let megapixels = (width * height) / 1_000_000
    62â†’        return megapixels >= 40 // 40MPä»¥ä¸Šè®¤ä¸ºæ˜¯è¶…å¤§å›¾åƒ
    63â†’    }
    64â†’    
    65â†’    // è¶…å¤§å›¾åƒç›´æ¥ä¿å­˜ï¼ˆé›¶å¤„ç†ï¼‰
    66â†’    private func saveUltraLargeImageDirectly(_ imageData: Data) {
    67â†’        PHPhotoLibrary.shared().performChanges({
    68â†’            let creationRequest = PHAssetCreationRequest.forAsset()
    69â†’            
    70â†’            // ç›´æ¥ä¿å­˜åŸå§‹æ•°æ®ï¼Œä¸åšä»»ä½•å¤„ç†
    71â†’            creationRequest.addResource(with: .photo, data: imageData, options: nil)
    72â†’            
    73â†’            // å¦‚æœæœ‰ä½ç½®ä¿¡æ¯ï¼Œæ·»åŠ GPSæ•°æ®
    74â†’            if let location = self.locationManager.currentLocation {
    75â†’                creationRequest.location = location
    76â†’                print("ğŸ“ æ·»åŠ GPSä½ç½®ä¿¡æ¯: \(location.coordinate)")
    77â†’            }
    78â†’            
    79â†’        }) { success, error in
    80â†’            if let error = error {
    81â†’                print("âŒ è¶…å¤§å›¾åƒä¿å­˜å¤±è´¥: \(error)")
    82â†’            } else if success {
    83â†’                print("âœ… è¶…å¤§å›¾åƒç›´æ¥ä¿å­˜æˆåŠŸï¼ˆé›¶å¤„ç†æ¨¡å¼ï¼‰")
    84â†’            }
    85â†’        }
    86â†’    }
    87â†’    
    88â†’    // å°†ä¿å­˜åˆ°ç›¸å†Œçš„æ“ä½œæå–ä¸ºå•ç‹¬çš„æ–¹æ³•ï¼Œä¾¿äºå†…å­˜ç®¡ç†
    89â†’    private func saveImageDataToPhotoLibrary(_ imageData: Data) {
    90â†’        PHPhotoLibrary.shared().performChanges({ [weak self] in
    91â†’            let creationRequest = PHAssetCreationRequest.forAsset()
    92â†’            
    93â†’            // ä½¿ç”¨å¢å¼ºåçš„å›¾åƒæ•°æ®
    94â†’            creationRequest.addResource(with: .photo, data: imageData, options: nil)
    95â†’            
    96â†’            // å¦‚æœæœ‰ä½ç½®ä¿¡æ¯ï¼Œæ·»åŠ GPSæ•°æ®
    97â†’            if let location = self?.locationManager.currentLocation {
    98â†’                creationRequest.location = location
    99â†’                print("ğŸ“ æ·»åŠ GPSä½ç½®ä¿¡æ¯: \(location.coordinate)")
   100â†’            }
   101â†’            
   102â†’        }) { success, error in
   103â†’            if let error = error {
   104â†’                print("âŒ ä¿å­˜ç…§ç‰‡å¤±è´¥: \(error)")
   105â†’            } else if success {
   106â†’                print("âœ… ç…§ç‰‡å·²æˆåŠŸä¿å­˜åˆ°ç›¸å†Œï¼ŒåŒ…å«å®Œæ•´å…ƒæ•°æ®")
   107â†’            }
   108â†’        }
   109â†’    }
   110â†’    
   111â†’    private func createImageWithCompleteMetadata(from imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio? = nil) -> Data? {
   112â†’        var resultData: Data?
   113â†’        
   114â†’        // ä½¿ç”¨autoreleasepoolå‡å°‘å†…å­˜å ç”¨
   115â†’        autoreleasepool {
   116â†’            guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else {
   117â†’                print("âŒ æ— æ³•åˆ›å»ºCGImageSource")
   118â†’                resultData = imageData // è¿”å›åŸå§‹æ•°æ®ä½œä¸ºå¤‡é€‰
   119â†’                return
   120â†’            }
   121â†’            
   122â†’            // ğŸš¨ å…³é”®ä¼˜åŒ–ï¼šå…ˆæ£€æŸ¥å›¾åƒå°ºå¯¸ï¼Œé¿å…åŠ è½½å·¨å¤§å›¾åƒåˆ°å†…å­˜
   123â†’            guard let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
   124â†’                  let originalWidth = properties[kCGImagePropertyPixelWidth as String] as? Int,
   125â†’                  let originalHeight = properties[kCGImagePropertyPixelHeight as String] as? Int else {
   126â†’                print("âŒ æ— æ³•è·å–å›¾åƒå±æ€§")
   127â†’                resultData = imageData
   128â†’                return
   129â†’            }
   130â†’            
   131â†’            let originalMegapixels = (originalWidth * originalHeight) / 1_000_000
   132â†’            
   133â†’            print("ğŸ” åŸå§‹å›¾åƒå°ºå¯¸æ£€æŸ¥:")
   134â†’            print("  - å®½åº¦: \(originalWidth)")
   135â†’            print("  - é«˜åº¦: \(originalHeight)")
   136â†’            print("  - æ€»åƒç´ : \(originalMegapixels)MP")
   137â†’            print("  - æ˜¯å¦ä¸º48MP: \(originalMegapixels >= 40)")
   138â†’            
   139â†’            // ğŸš¨ 48MPå›¾åƒç‰¹æ®Šå¤„ç†ï¼šé¿å…å†…å­˜çˆ†ç‚¸
   140â†’            if originalMegapixels >= 40 {
   141â†’                print("ğŸš¨ æ£€æµ‹åˆ°48MPå›¾åƒï¼å¯ç”¨æç®€å¤„ç†æ¨¡å¼")
   142â†’                resultData = handleUltraHighResolutionImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   143â†’                return
   144â†’            } else if originalMegapixels >= 20 {
   145â†’                print("âš¡ æ£€æµ‹åˆ°å¤§å°ºå¯¸å›¾åƒï¼Œå¯ç”¨ä¼˜åŒ–å¤„ç†")
   146â†’                resultData = handleLargeImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   147â†’                return
   148â†’            }
   149â†’            
   150â†’            print("âœ… æ ‡å‡†å›¾åƒï¼Œä½¿ç”¨å¸¸è§„å¤„ç†")
   151â†’            
   152â†’            // å¸¸è§„å›¾åƒå¤„ç†ï¼ˆå°äº20MPï¼‰
   153â†’            guard let cgImage = CGImageSourceCreateImageAtIndex(source, 0, nil) else {
   154â†’                print("âŒ æ— æ³•åˆ›å»ºCGImage")
   155â†’                resultData = imageData
   156â†’                return
   157â†’            }
   158â†’            
   159â†’            // å¤„ç†æ¯”ä¾‹è£å‰ª
   160â†’            let finalCGImage: CGImage
   161â†’            if let aspectRatio = aspectRatio, aspectRatio != .ratio4_3 {
   162â†’                print("ğŸ”„ åº”ç”¨æ¯”ä¾‹è£å‰ª: \(aspectRatio.rawValue)")
   163â†’                finalCGImage = cropImageToAspectRatio(cgImage, aspectRatio: aspectRatio)
   164â†’            } else {
   165â†’                print("ğŸ“· ä¿æŒåŸå§‹æ¯”ä¾‹")
   166â†’                finalCGImage = cgImage
   167â†’            }
   168â†’            
   169â†’            // è·å–åŸå§‹å…ƒæ•°æ® - ä¼˜åŒ–ï¼šåªè·å–éœ€è¦çš„å…ƒæ•°æ®
   170â†’            var metadata: [String: Any] = [:]
   171â†’            if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   172â†’                // åªå¤åˆ¶éœ€è¦çš„å…ƒæ•°æ®å­—å…¸
   173â†’                if let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   174â†’                    metadata[kCGImagePropertyExifDictionary as String] = exif
   175â†’                }
   176â†’                if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   177â†’                    metadata[kCGImagePropertyTIFFDictionary as String] = tiff
   178â†’                }
   179â†’                if let gps = properties[kCGImagePropertyGPSDictionary as String] as? [String: Any] {
   180â†’                    metadata[kCGImagePropertyGPSDictionary as String] = gps
   181â†’                }
   182â†’            }
   183â†’            
   184â†’            print("ğŸ“¸ åŸå§‹å…ƒæ•°æ®å­—æ®µ:")
   185â†’            print("  - æ€»å­—æ®µæ•°: \(metadata.keys.count)")
   186â†’            
   187â†’            // ä¿ç•™å¹¶è¡¥å……EXIFä¿¡æ¯ï¼ˆä¸è¦†ç›–å·²æœ‰çš„é‡è¦ä¿¡æ¯ï¼‰
   188â†’            var exifDict = metadata[kCGImagePropertyExifDictionary as String] as? [String: Any] ?? [:]
   189â†’            
   190â†’            // åªåœ¨æ²¡æœ‰é•œå¤´ä¿¡æ¯æ—¶æ‰æ·»åŠ 
   191â†’            if exifDict[kCGImagePropertyExifLensMake as String] == nil {
   192â†’                exifDict[kCGImagePropertyExifLensMake as String] = "Apple"
   193â†’            }
   194â†’            if exifDict[kCGImagePropertyExifLensModel as String] == nil {
   195â†’                exifDict[kCGImagePropertyExifLensModel as String] = DeviceInfoHelper.getLensModelForPhotos(device: AVCaptureDevice.default(for: .video)!)
   196â†’            }
   197â†’            
   198â†’            // æ·»åŠ æ‹æ‘„æ—¶é—´ï¼ˆå¦‚æœæ²¡æœ‰çš„è¯ï¼‰
   199â†’            if exifDict[kCGImagePropertyExifDateTimeOriginal as String] == nil {
   200â†’                let now = Date()
   201â†’                let dateFormatter = DateFormatter()
   202â†’                dateFormatter.dateFormat = "yyyy:MM:dd HH:mm:ss"
   203â†’                exifDict[kCGImagePropertyExifDateTimeOriginal as String] = dateFormatter.string(from: now)
   204â†’                exifDict[kCGImagePropertyExifDateTimeDigitized as String] = dateFormatter.string(from: now)
   205â†’            }
   206â†’            
   207â†’            // ä¿ç•™å¹¶è¡¥å……TIFFä¿¡æ¯
   208â†’            var tiffDict = metadata[kCGImagePropertyTIFFDictionary as String] as? [String: Any] ?? [:]
   209â†’            
   210â†’            // åªåœ¨æ²¡æœ‰è®¾å¤‡ä¿¡æ¯æ—¶æ‰æ·»åŠ 
   211â†’            if tiffDict[kCGImagePropertyTIFFMake as String] == nil {
   212â†’                tiffDict[kCGImagePropertyTIFFMake as String] = "Apple"
   213â†’            }
   214â†’            if tiffDict[kCGImagePropertyTIFFModel as String] == nil {
   215â†’                tiffDict[kCGImagePropertyTIFFModel as String] = DeviceInfoHelper.getDetailedDeviceModel()
   216â†’            }
   217â†’            if tiffDict[kCGImagePropertyTIFFSoftware as String] == nil {
   218â†’                tiffDict[kCGImagePropertyTIFFSoftware as String] = "MCCamera 1.0.0"
   219â†’            }
   220â†’            
   221â†’            // æ·»åŠ æ—¶é—´æˆ³ï¼ˆå¦‚æœæ²¡æœ‰çš„è¯ï¼‰
   222â†’            if tiffDict[kCGImagePropertyTIFFDateTime as String] == nil {
   223â†’                let now = Date()
   224â†’                let dateFormatter = DateFormatter()
   225â†’                dateFormatter.dateFormat = "yyyy:MM:dd HH:mm:ss"
   226â†’                tiffDict[kCGImagePropertyTIFFDateTime as String] = dateFormatter.string(from: now)
   227â†’            }
   228â†’            
   229â†’            // æ·»åŠ GPSä¿¡æ¯ï¼ˆå¦‚æœæœ‰ä½ç½®æ•°æ®ä¸”æ²¡æœ‰GPSä¿¡æ¯ï¼‰
   230â†’            if metadata[kCGImagePropertyGPSDictionary as String] == nil,
   231â†’               let gpsMetadata = locationManager.getLocationMetadata() {
   232â†’                metadata[kCGImagePropertyGPSDictionary as String] = gpsMetadata
   233â†’            }
   234â†’            
   235â†’            // æ›´æ–°å…ƒæ•°æ®
   236â†’            metadata[kCGImagePropertyExifDictionary as String] = exifDict
   237â†’            metadata[kCGImagePropertyTIFFDictionary as String] = tiffDict
   238â†’            
   239â†’            // æ ¹æ®æ ¼å¼å’Œå›¾åƒå¤§å°é€‰æ‹©è¾“å‡ºç±»å‹
   240â†’            let outputType: CFString
   241â†’            let compressionQuality: Float
   242â†’            
   243â†’            // ğŸ”„ å…³é”®ä¼˜åŒ–ï¼šå¯¹äºå¤§å°ºå¯¸å›¾åƒï¼Œä½¿ç”¨JPEGæ ¼å¼è€Œä¸æ˜¯HEICæ ¼å¼
   244â†’            let useJpegForLargeImages = originalMegapixels > 20
   245â†’            
   246â†’            switch format {
   247â†’            case .heic:
   248â†’                if useJpegForLargeImages {
   249â†’                    print("ğŸ“¸ å¤§å°ºå¯¸å›¾åƒ(\(originalMegapixels)MP)ï¼Œä½¿ç”¨JPEGæ ¼å¼ä»£æ›¿HEICä»¥å‡å°‘å†…å­˜ä½¿ç”¨")
   250â†’                    outputType = UTType.jpeg.identifier as CFString
   251â†’                    compressionQuality = 0.85 // é™ä½å‹ç¼©è´¨é‡ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
   252â†’                } else {
   253â†’                    print("  - è½¬æ¢ä¸ºHEICæ ¼å¼...")
   254â†’                    outputType = UTType.heic.identifier as CFString
   255â†’                    compressionQuality = 0.85 // é™ä½å‹ç¼©è´¨é‡ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
   256â†’                }
   257â†’            case .jpeg:
   258â†’                outputType = UTType.jpeg.identifier as CFString
   259â†’                compressionQuality = 0.85 // é™ä½å‹ç¼©è´¨é‡ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
   260â†’            case .raw:
   261â†’                // RAWæ ¼å¼é€šå¸¸ä¸éœ€è¦é‡æ–°ç¼–ç ï¼Œç›´æ¥è¿”å›åŸå§‹æ•°æ®
   262â†’                print("ğŸ“¸ RAWæ ¼å¼ä¿æŒåŸå§‹æ•°æ®")
   263â†’                resultData = imageData
   264â†’                return
   265â†’            }
   266â†’            
   267â†’            // ğŸ”„ å…³é”®ä¼˜åŒ–ï¼šæ™ºèƒ½å¤„ç†å¤§å°ºå¯¸å›¾åƒ
   268â†’            let processedCGImage: CGImage
   269â†’            if originalMegapixels > 30 { // å¯¹äºéå¸¸å¤§çš„å›¾åƒï¼ˆå¦‚48MPï¼‰
   270â†’                print("ğŸ“¸ ä½¿ç”¨å†…å­˜ä¼˜åŒ–ç­–ç•¥å¤„ç†å¤§å°ºå¯¸å›¾åƒ")
   271â†’                processedCGImage = processLargeImageWithMemoryOptimization(finalCGImage, originalMegapixels: originalMegapixels)
   272â†’            } else {
   273â†’                processedCGImage = finalCGImage
   274â†’            }
   275â†’            
   276â†’            // åˆ›å»ºæ–°çš„å›¾åƒæ•°æ®
   277â†’            let mutableData = NSMutableData()
   278â†’            guard let destination = CGImageDestinationCreateWithData(mutableData, outputType, 1, nil) else {
   279â†’                print("âŒ æ— æ³•åˆ›å»ºCGImageDestination")
   280â†’                resultData = imageData
   281â†’                return
   282â†’            }
   283â†’            
   284â†’            // è®¾ç½®å‹ç¼©è´¨é‡å’Œå…¶ä»–é€‰é¡¹
   285â†’            var options: [CFString: Any] = [
   286â†’                kCGImageDestinationLossyCompressionQuality: compressionQuality,
   287â†’                kCGImageDestinationOptimizeColorForSharing: true // ä¼˜åŒ–é¢œè‰²å…±äº«
   288â†’            ]
   289â†’            
   290â†’            // å¯¹äºHEICæ ¼å¼ï¼Œæ·»åŠ é¢å¤–çš„ä¼˜åŒ–é€‰é¡¹
   291â†’            if outputType == UTType.heic.identifier as CFString {
   292â†’                options[kCGImageDestinationEmbedThumbnail] = false // ä¸åµŒå…¥ç¼©ç•¥å›¾ä»¥å‡å°‘å†…å­˜ä½¿ç”¨
   293â†’            }
   294â†’            
   295â†’            // å…ˆè®¾ç½®å±æ€§ï¼Œå†æ·»åŠ å›¾åƒ
   296â†’            CGImageDestinationSetProperties(destination, options as CFDictionary)
   297â†’            
   298â†’            // æ·»åŠ å›¾åƒå’Œå…ƒæ•°æ®
   299â†’            CGImageDestinationAddImage(destination, processedCGImage, metadata as CFDictionary)
   300â†’            
   301â†’            // å®Œæˆå†™å…¥
   302â†’            guard CGImageDestinationFinalize(destination) else {
   303â†’                print("âŒ æ— æ³•å®Œæˆå›¾åƒå†™å…¥")
   304â†’                resultData = imageData
   305â†’                return
   306â†’            }
   307â†’            
   308â†’            // éªŒè¯ä¿å­˜çš„å…ƒæ•°æ®
   309â†’            verifyMetadata(mutableData)
   310â†’            
   311â†’            print("âœ… æˆåŠŸåˆ›å»ºå¸¦æœ‰å®Œæ•´å…ƒæ•°æ®çš„å›¾åƒï¼Œæ ¼å¼: \(outputType == UTType.heic.identifier as CFString ? "HEIC" : "JPEG")")
   312â†’            resultData = mutableData as Data
   313â†’        }
   314â†’        
   315â†’        return resultData
   316â†’    }
   317â†’    
   318â†’    // 48MPå›¾åƒæç®€å¤„ç† - é¿å…å†…å­˜çˆ†ç‚¸
   319â†’    private func handleUltraHighResolutionImage(source: CGImageSource, imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio?) -> Data {
   320â†’        print("ğŸ”¥ 48MPæç®€å¤„ç†æ¨¡å¼")
   321â†’        
   322â†’        // æ£€æŸ¥å½“å‰å†…å­˜å‹åŠ›
   323â†’        let memoryUsage = MemoryMonitor.shared.getCurrentMemoryUsage()
   324â†’        let usedMB = memoryUsage.used / 1024 / 1024
   325â†’        
   326â†’        // å¦‚æœå†…å­˜å‹åŠ›æå¤§ï¼Œç›´æ¥è¿”å›åŸå§‹æ•°æ®
   327â†’        if usedMB > 300 {
   328â†’            print("ğŸš¨ å†…å­˜å‹åŠ›è¿‡å¤§(\(usedMB)MB)ï¼Œç›´æ¥ä¿å­˜åŸå§‹æ•°æ®")
   329â†’            return imageData
   330â†’        }
   331â†’        
   332â†’        // å¦‚æœæ²¡æœ‰è£å‰ªéœ€æ±‚ä¸”æ ¼å¼åŒ¹é…ï¼Œç›´æ¥è¿”å›åŸå§‹æ•°æ®
   333â†’        if aspectRatio == nil || aspectRatio == .ratio4_3 {
   334â†’            print("ğŸš€ æ— éœ€å¤„ç†ï¼Œç›´æ¥ä¿å­˜åŸå§‹48MPæ•°æ®")
   335â†’            return imageData
   336â†’        }
   337â†’        
   338â†’        print("ğŸ“ æ·»åŠ æœ€å°‘å…ƒæ•°æ®åä¿å­˜")
   339â†’        
   340â†’        // åªåœ¨å¿…è¦æ—¶æ·»åŠ æœ€å°‘çš„å…ƒæ•°æ®
   341â†’        var metadata: [String: Any] = [:]
   342â†’        
   343â†’        // è·å–åŸå§‹å±æ€§ï¼ˆè½»é‡çº§æ“ä½œï¼‰
   344â†’        if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   345â†’            // åªä¿ç•™æœ€é‡è¦çš„å…ƒæ•°æ®
   346â†’            if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   347â†’                var tiffDict = tiff
   348â†’                tiffDict[kCGImagePropertyTIFFSoftware as String] = "MCCamera 1.0.0"
   349â†’                metadata[kCGImagePropertyTIFFDictionary as String] = tiffDict
   350â†’            }
   351â†’        }
   352â†’        
   353â†’        // ä½¿ç”¨æœ€ç®€å•çš„é‡å†™æ–¹å¼
   354â†’        let mutableData = NSMutableData()
   355â†’        let outputType = UTType.heic.identifier as CFString // ä¿æŒåŸæ ¼å¼
   356â†’        
   357â†’        guard let destination = CGImageDestinationCreateWithData(mutableData, outputType, 1, nil) else {
   358â†’            print("âŒ åˆ›å»ºdestinationå¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®")
   359â†’            return imageData
   360â†’        }
   361â†’        
   362â†’        // æœ€å°åŒ–çš„å¤„ç†é€‰é¡¹
   363â†’        let options: [CFString: Any] = [
   364â†’            kCGImageDestinationLossyCompressionQuality: 0.95 // æœ€å°å‹ç¼©
   365â†’        ]
   366â†’        
   367â†’        CGImageDestinationSetProperties(destination, options as CFDictionary)
   368â†’        
   369â†’        // é›¶æ‹·è´ç­–ç•¥ï¼šç›´æ¥ä»sourceåˆ°destination
   370â†’        CGImageDestinationAddImageFromSource(destination, source, 0, metadata as CFDictionary)
   371â†’        
   372â†’        guard CGImageDestinationFinalize(destination) else {
   373â†’            print("âŒ å†™å…¥å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®")
   374â†’            return imageData
   375â†’        }
   376â†’        
   377â†’        print("âœ… 48MPæœ€å°åŒ–å¤„ç†å®Œæˆ")
   378â†’        return mutableData as Data
   379â†’    }
   380â†’    
   381â†’    // å¤§å›¾åƒä¼˜åŒ–å¤„ç†ï¼ˆ20-40MPï¼‰
   382â†’    private func handleLargeImage(source: CGImageSource, imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio?) -> Data {
   383â†’        print("âš¡ å¤§å›¾åƒä¼˜åŒ–å¤„ç†")
   384â†’        
   385â†’        // ä½¿ç”¨é™é‡‡æ ·æŠ€æœ¯ï¼Œé¿å…å°†å®Œæ•´å›¾åƒåŠ è½½åˆ°å†…å­˜
   386â†’        let maxPixelSize = 3000 // é™åˆ¶æœ€å¤§è¾¹é•¿ä¸º3000px
   387â†’        
   388â†’        let options: [CFString: Any] = [
   389â†’            kCGImageSourceCreateThumbnailFromImageAlways: true,
   390â†’            kCGImageSourceCreateThumbnailWithTransform: true,
   391â†’            kCGImageSourceThumbnailMaxPixelSize: maxPixelSize,
   392â†’            kCGImageSourceShouldCache: false
   393â†’        ]
   394â†’        
   395â†’        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
   396â†’            print("âŒ å¤§å›¾åƒé™é‡‡æ ·å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®")
   397â†’            return imageData
   398â†’        }
   399â†’        
   400â†’        print("ğŸ“‰ å¤§å›¾åƒå·²é™é‡‡æ ·è‡³: \(downsampledImage.width)Ã—\(downsampledImage.height)")
   401â†’        
   402â†’        // è·å–å…ƒæ•°æ®
   403â†’        var metadata: [String: Any] = [:]
   404â†’        if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   405â†’            if let exif = properties[kCGImagePropertyExifDictionary as String] {
   406â†’                metadata[kCGImagePropertyExifDictionary as String] = exif
   407â†’            }
   408â†’            if let tiff = properties[kCGImagePropertyTIFFDictionary as String] {
   409â†’                metadata[kCGImagePropertyTIFFDictionary as String] = tiff
   410â†’            }
   411â†’        }
   412â†’        
   413â†’        // åˆ›å»ºè¾“å‡º
   414â†’        let mutableData = NSMutableData()
   415â†’        let outputType = UTType.jpeg.identifier as CFString
   416â†’        guard let destination = CGImageDestinationCreateWithData(mutableData, outputType, 1, nil) else {
   417â†’            return imageData
   418â†’        }
   419â†’        
   420â†’        let compressionOptions: [CFString: Any] = [
   421â†’            kCGImageDestinationLossyCompressionQuality: 0.8
   422â†’        ]
   423â†’        
   424â†’        CGImageDestinationAddImage(destination, downsampledImage, metadata as CFDictionary)
   425â†’        CGImageDestinationSetProperties(destination, compressionOptions as CFDictionary)
   426â†’        
   427â†’        guard CGImageDestinationFinalize(destination) else {
   428â†’            return imageData
   429â†’        }
   430â†’        
   431â†’        print("âœ… å¤§å›¾åƒä¼˜åŒ–å¤„ç†å®Œæˆ")
   432â†’        return mutableData as Data
   433â†’    }
   434â†’    
   435â†’    // å†…å­˜ä¼˜åŒ–çš„å¤§å›¾åƒå¤„ç†
   436â†’    private func processLargeImageWithMemoryOptimization(_ cgImage: CGImage, originalMegapixels: Int) -> CGImage {
   437â†’        var result = cgImage
   438â†’        
   439â†’        autoreleasepool {
   440â†’            // è®¡ç®—ç›®æ ‡å°ºå¯¸ - æ™ºèƒ½ç¼©æ”¾åˆ°åˆé€‚å¤§å°
   441â†’            let targetMegapixels = min(Double(originalMegapixels), 25.0) // æœ€å¤§25MP
   442â†’            let scaleFactor = sqrt(targetMegapixels / Double(originalMegapixels))
   443â†’            
   444â†’            let newWidth = Int(Double(cgImage.width) * scaleFactor)
   445â†’            let newHeight = Int(Double(cgImage.height) * scaleFactor)
   446â†’            
   447â†’            print("ğŸ“¸ æ™ºèƒ½ç¼©æ”¾: \(cgImage.width)Ã—\(cgImage.height) -> \(newWidth)Ã—\(newHeight) (ç¼©æ”¾å› å­: \(scaleFactor))")
   448â†’            
   449â†’            // ä½¿ç”¨æ›´ç²¾ç¡®çš„ç¼©æ”¾ç®—æ³•
   450â†’            if let scaledImage = createHighQualityScaledImage(from: cgImage, targetSize: CGSize(width: newWidth, height: newHeight)) {
   451â†’                result = scaledImage
   452â†’                print("âœ… å¤§å›¾åƒå†…å­˜ä¼˜åŒ–å®Œæˆ")
   453â†’            } else {
   454â†’                print("âš ï¸ å¤§å›¾åƒç¼©æ”¾å¤±è´¥ï¼Œä½¿ç”¨åŸå›¾")
   455â†’            }
   456â†’        }
   457â†’        
   458â†’        return result
   459â†’    }
   460â†’    
   461â†’    // åˆ›å»ºé«˜è´¨é‡ç¼©æ”¾å›¾åƒ
   462â†’    private func createHighQualityScaledImage(from cgImage: CGImage, targetSize: CGSize) -> CGImage? {
   463â†’        autoreleasepool {
   464â†’            // ä½¿ç”¨å†…å­˜æ•ˆç‡æ›´é«˜çš„é¢œè‰²ç©ºé—´
   465â†’            let colorSpace = CGColorSpaceCreateDeviceRGB()
   466â†’            
   467â†’            // è®¡ç®—åˆé€‚çš„å­—èŠ‚å¯¹é½
   468â†’            let bytesPerRow = Int(targetSize.width) * 4
   469â†’            let alignedBytesPerRow = (bytesPerRow + 15) & ~15 // 16å­—èŠ‚å¯¹é½ä¼˜åŒ–æ€§èƒ½
   470â†’            
   471â†’            guard let context = CGContext(
   472â†’                data: nil,
   473â†’                width: Int(targetSize.width),
   474â†’                height: Int(targetSize.height),
   475â†’                bitsPerComponent: 8,
   476â†’                bytesPerRow: alignedBytesPerRow,
   477â†’                space: colorSpace,
   478â†’                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue | CGBitmapInfo.byteOrder32Big.rawValue
   479â†’            ) else {
   480â†’                print("âŒ æ— æ³•åˆ›å»ºä¼˜åŒ–çš„å›¾å½¢ä¸Šä¸‹æ–‡")
   481â†’                return nil
   482â†’            }
   483â†’            
   484â†’            // è®¾ç½®é«˜è´¨é‡æ’å€¼
   485â†’            context.interpolationQuality = .high
   486â†’            
   487â†’            // ç»˜åˆ¶ç¼©æ”¾åçš„å›¾åƒ
   488â†’            context.draw(cgImage, in: CGRect(origin: .zero, size: targetSize))
   489â†’            
   490â†’            return context.makeImage()
   491â†’        }
   492â†’    }
   493â†’    
   494â†’    private func verifyMetadata(_ data: NSMutableData) {
   495â†’        autoreleasepool {
   496â†’            if let verifySource = CGImageSourceCreateWithData(data, nil),
   497â†’               let verifyMetadata = CGImageSourceCopyPropertiesAtIndex(verifySource, 0, nil) as? [String: Any] {
   498â†’                print("ğŸ“‹ éªŒè¯ä¿å­˜çš„å…ƒæ•°æ®:")
   499â†’                
   500â†’                if let verifyExif = verifyMetadata[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   501â†’                    print("  - EXIFå­—æ®µæ•°é‡: \(verifyExif.keys.count)")
   502â†’                    if let lensMake = verifyExif[kCGImagePropertyExifLensMake as String] {
   503â†’                        print("  - é•œå¤´åˆ¶é€ å•†: \(lensMake)")
   504â†’                    }
   505â†’                    if let lensModel = verifyExif[kCGImagePropertyExifLensModel as String] {
   506â†’                        print("  - é•œå¤´å‹å·: \(lensModel)")
   507â†’                    }
   508â†’                    if let dateTime = verifyExif[kCGImagePropertyExifDateTimeOriginal as String] {
   509â†’                        print("  - æ‹æ‘„æ—¶é—´: \(dateTime)")
   510â†’                    }
   511â†’                    if let iso = verifyExif[kCGImagePropertyExifISOSpeedRatings as String] {
   512â†’                        print("  - ISO: \(iso)")
   513â†’                    }
   514â†’                    if let exposureTime = verifyExif[kCGImagePropertyExifExposureTime as String] {
   515â†’                        print("  - å¿«é—¨é€Ÿåº¦: \(exposureTime)")
   516â†’                    }
   517â†’                }
   518â†’                
   519â†’                if let verifyTiff = verifyMetadata[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   520â†’                    print("  - TIFFå­—æ®µæ•°é‡: \(verifyTiff.keys.count)")
   521â†’                    if let make = verifyTiff[kCGImagePropertyTIFFMake as String] {
   522â†’                        print("  - è®¾å¤‡åˆ¶é€ å•†: \(make)")
   523â†’                    }
   524â†’                    if let model = verifyTiff[kCGImagePropertyTIFFModel as String] {
   525â†’                        print("  - è®¾å¤‡å‹å·: \(model)")
   526â†’                    }
   527â†’                }
   528â†’                
   529â†’                if let verifyGPS = verifyMetadata[kCGImagePropertyGPSDictionary as String] as? [String: Any] {
   530â†’                    print("  - GPSå­—æ®µæ•°é‡: \(verifyGPS.keys.count)")
   531â†’                } else {
   532â†’                    print("  - æ— GPSä¿¡æ¯")
   533â†’                }
   534â†’            } else {
   535â†’                print("âŒ æ— æ³•éªŒè¯ä¿å­˜çš„å…ƒæ•°æ®")
   536â†’            }
   537â†’        }
   538â†’    }
   539â†’    
   540â†’    private func cropImageToAspectRatio(_ cgImage: CGImage, aspectRatio: AspectRatio) -> CGImage {
   541â†’        let originalWidth = cgImage.width
   542â†’        let originalHeight = cgImage.height
   543â†’        let originalSize = CGSize(width: originalWidth, height: originalHeight)
   544â†’        
   545â†’        print("ğŸ”„ è£å‰ªå›¾åƒ:")
   546â†’        print("  - åŸå§‹å°ºå¯¸: \(originalWidth) x \(originalHeight)")
   547â†’        print("  - ç›®æ ‡æ¯”ä¾‹: \(aspectRatio.rawValue) (\(aspectRatio.ratioValue))")
   548â†’        
   549â†’        // è®¡ç®—è£å‰ªåŒºåŸŸ
   550â†’        let cropRect = aspectRatio.getCropRect(for: originalSize)
   551â†’        
   552â†’        print("  - è£å‰ªåŒºåŸŸ: \(cropRect)")
   553â†’        print("  - è£å‰ªåå°ºå¯¸: \(Int(cropRect.width)) x \(Int(cropRect.height))")
   554â†’        
   555â†’        // æ‰§è¡Œè£å‰ª
   556â†’        if let croppedImage = cgImage.cropping(to: cropRect) {
   557â†’            print("âœ… å›¾åƒè£å‰ªæˆåŠŸ")
   558â†’            return croppedImage
   559â†’        } else {
   560â†’            print("âŒ å›¾åƒè£å‰ªå¤±è´¥ï¼Œè¿”å›åŸå›¾")
   561â†’            return cgImage
   562â†’        }
   563â†’    }
   564â†’    
   565â†’    private func logOriginalMetadata(_ imageData: Data) {
   566â†’        autoreleasepool {
   567â†’            guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
   568â†’                  let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] else {
   569â†’                print("ğŸ“¸ æ— æ³•è¯»å–åŸå§‹ç…§ç‰‡å…ƒæ•°æ®")
   570â†’                return
   571â†’            }
   572â†’            
   573â†’            print("ğŸ“¸ åŸå§‹ç…§ç‰‡å…ƒæ•°æ®:")
   574â†’            if let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   575â†’                print("  - EXIFæ•°æ®å­˜åœ¨ï¼ŒåŒ…å« \(exif.keys.count) ä¸ªå­—æ®µ")
   576â†’                if let iso = exif[kCGImagePropertyExifISOSpeedRatings as String] {
   577â†’                    print("  - ISO: \(iso)")
   578â†’                }
   579â†’                if let exposureTime = exif[kCGImagePropertyExifExposureTime as String] {
   580â†’                    print("  - å¿«é—¨é€Ÿåº¦: \(exposureTime)")
   581â†’                }
   582â†’            } else {
   583â†’                print("  - æ— EXIFæ•°æ®")
   584â†’            }
   585â†’            
   586â†’            if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   587â†’                print("  - TIFFæ•°æ®å­˜åœ¨")
   588â†’                if let make = tiff[kCGImagePropertyTIFFMake as String] {
   589â†’                    print("  - åˆ¶é€ å•†: \(make)")
   590â†’                }
   591â†’            }
   592â†’        }
   593â†’    }
   594â†’}
```

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] ğŸŒ¡ï¸ Analyze PhotoProcessor.swift for memory issues
- [âš¡] ğŸŒ¡ï¸ Check PhotoDecorationService.swift for memory leaks
- [ ] ğŸŒ¡ï¸ Review camera capture flow for proper memory management
- [ ] ğŸŒ¡ï¸ Implement image memory optimization techniques
- [ ] ğŸŒ¡ï¸ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Features/Frame/Services/PhotoDecorationService.swift`

Result:

```
1â†’import Foundation
     2â†’import UIKit
     3â†’import CoreLocation
     4â†’
     5â†’class PhotoDecorationService {
     6â†’    private let frameSettings: FrameSettings
     7â†’    private let renderer: OptimizedPhotoDecorationRenderer
     8â†’    private let layoutEngine: InfoLayoutEngine
     9â†’    
    10â†’    init(frameSettings: FrameSettings) {
    11â†’        self.frameSettings = frameSettings
    12â†’        self.renderer = OptimizedPhotoDecorationRenderer()
    13â†’        self.layoutEngine = InfoLayoutEngine()
    14â†’    }
    15â†’    
    16â†’    // åº”ç”¨ç›¸æ¡†åˆ°ç…§ç‰‡ - æç«¯å†…å­˜ä¼˜åŒ–ç‰ˆæœ¬
    17â†’    func applyFrameToPhoto(_ imageData: Data) -> Data {
    18â†’        // å¦‚æœæ²¡æœ‰é€‰æ‹©ç›¸æ¡†ï¼Œç›´æ¥è¿”å›åŸå›¾
    19â†’        guard frameSettings.selectedFrame != .none else {
    20â†’            return imageData
    21â†’        }
    22â†’        
    23â†’        var finalImageData = imageData
    24â†’        
    25â†’        // å†…å­˜ç›‘æ§å’Œå‹åŠ›æ£€æŸ¥
    26â†’        MemoryMonitor.shared.logMemoryUsage(context: "ç›¸æ¡†å¤„ç†å¼€å§‹")
    27â†’        
    28â†’        // æ ¹æ®å†…å­˜å‹åŠ›è°ƒæ•´å¤„ç†ç­–ç•¥
    29â†’        let processingStrategy = MemoryPressureManager.shared.getOptimalProcessingStrategy()
    30â†’        let pixelCount = getImagePixelCount(from: imageData)
    31â†’        
    32â†’        print("ğŸ“Š å¤„ç†å›¾åƒåƒç´ æ•°: \(pixelCount / 1_000_000)MPï¼Œç­–ç•¥: \(processingStrategy)")
    33â†’        
    34â†’        // å¦‚æœå†…å­˜å‹åŠ›è¿‡å¤§ï¼Œæ‰§è¡Œé¢„é˜²æ€§æ¸…ç†
    35â†’        MemoryPressureManager.shared.performPreventiveCleanup()
    36â†’        
    37â†’        // ä½¿ç”¨å¤šå±‚autoreleasepoolå‡å°‘å†…å­˜å³°å€¼
    38â†’        autoreleasepool {
    39â†’            // ç¬¬ä¸€å±‚ï¼šè·å–å…ƒæ•°æ®ï¼ˆè½»é‡çº§æ“ä½œï¼‰
    40â†’            MemoryMonitor.shared.logMemoryUsage(context: "å…ƒæ•°æ®æå–å¼€å§‹")
    41â†’            let metadata = getMetadataFromImageData(imageData)
    42â†’            MemoryMonitor.shared.logMemoryUsage(context: "å…ƒæ•°æ®æå–å®Œæˆ")
    43â†’            
    44â†’            autoreleasepool {
    45â†’                // ç¬¬äºŒå±‚ï¼šå›¾åƒå¤„ç†ï¼ˆåŸºäºå†…å­˜å‹åŠ›è°ƒæ•´ï¼‰
    46â†’                MemoryMonitor.shared.logMemoryUsage(context: "å›¾åƒä¼˜åŒ–åˆ›å»ºå¼€å§‹")
    47â†’                guard let image = createAdaptiveOptimizedImage(from: imageData, pixelCount: pixelCount, strategy: processingStrategy) else {
    48â†’                    print("âŒ æ— æ³•åˆ›å»ºä¼˜åŒ–å›¾åƒ")
    49â†’                    return
    50â†’                }
    51â†’                MemoryMonitor.shared.logMemoryUsage(context: "å›¾åƒä¼˜åŒ–åˆ›å»ºå®Œæˆ")
    52â†’                
    53â†’                print("ğŸ“± ä½¿ç”¨å›¾åƒå°ºå¯¸: \(Int(image.size.width))Ã—\(Int(image.size.height))")
    54â†’                
    55â†’                autoreleasepool {
    56â†’                    // ç¬¬ä¸‰å±‚ï¼šæ¸²æŸ“è£…é¥°
    57â†’                    MemoryMonitor.shared.logMemoryUsage(context: "ç›¸æ¡†æ¸²æŸ“å¼€å§‹")
    58â†’                    let decoratedImage = renderer.renderDecoration(
    59â†’                        on: image,
    60â†’                        frameType: frameSettings.selectedFrame,
    61â†’                        customText: frameSettings.customText,
    62â†’                        showDate: frameSettings.showDate,
    63â†’                        showLocation: frameSettings.showLocation,
    64â†’                        showExif: frameSettings.showExif,
    65â†’                        showExifParams: frameSettings.showExifParams,
    66â†’                        showExifDate: frameSettings.showExifDate,
    67â†’                        selectedLogo: frameSettings.selectedLogo,
    68â†’                        showSignature: frameSettings.showSignature,
    69â†’                        metadata: metadata
    70â†’                    )
    71â†’                    MemoryMonitor.shared.logMemoryUsage(context: "ç›¸æ¡†æ¸²æŸ“å®Œæˆ")
    72â†’                    
    73â†’                    // è½¬æ¢å›Data - ä½¿ç”¨è‡ªé€‚åº”å‹ç¼©ç­–ç•¥
    74â†’                    autoreleasepool {
    75â†’                        MemoryMonitor.shared.logMemoryUsage(context: "å›¾åƒå‹ç¼©å¼€å§‹")
    76â†’                        let compressionQuality = processingStrategy.compressionQuality
    77â†’                        if let processedData = decoratedImage.jpegData(compressionQuality: compressionQuality) {
    78â†’                            finalImageData = processedData
    79â†’                            print("âœ… å›¾åƒå¤„ç†å®Œæˆï¼Œç­–ç•¥: \(processingStrategy)ï¼Œå‹ç¼©è´¨é‡: \(compressionQuality)")
    80â†’                        }
    81â†’                        MemoryMonitor.shared.logMemoryUsage(context: "å›¾åƒå‹ç¼©å®Œæˆ")
    82â†’                    }
    83â†’                }
    84â†’            }
    85â†’        }
    86â†’        
    87â†’        MemoryMonitor.shared.logMemoryUsage(context: "ç›¸æ¡†å¤„ç†ç»“æŸ")
    88â†’        
    89â†’        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼ºåˆ¶æ¸…ç†å†…å­˜
    90â†’        if MemoryMonitor.shared.shouldTriggerMemoryCleanup() {
    91â†’            MemoryMonitor.shared.forceMemoryCleanup()
    92â†’        }
    93â†’        
    94â†’        return finalImageData
    95â†’    }
    96â†’    
    97â†’    // è·å–å›¾åƒåƒç´ æ•°
    98â†’    private func getImagePixelCount(from imageData: Data) -> Int {
    99â†’        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
   100â†’              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
   101â†’              let width = properties[kCGImagePropertyPixelWidth as String] as? Int,
   102â†’              let height = properties[kCGImagePropertyPixelHeight as String] as? Int else {
   103â†’            return 0
   104â†’        }
   105â†’        return width * height
   106â†’    }
   107â†’    
   108â†’    // åŸºäºå†…å­˜å‹åŠ›çš„è‡ªé€‚åº”å›¾åƒåˆ›å»º
   109â†’    private func createAdaptiveOptimizedImage(from imageData: Data, pixelCount: Int, strategy: ImageProcessingStrategy) -> UIImage? {
   110â†’        let maxPixels = strategy.maxPixels
   111â†’        
   112â†’        print("ğŸ¯ è‡ªé€‚åº”å¤„ç†ï¼šåƒç´ æ•°\(pixelCount/1_000_000)MPï¼Œé™åˆ¶\(maxPixels/1_000_000)MP")
   113â†’        
   114â†’        // æ ¹æ®ç­–ç•¥å†³å®šå¤„ç†æ–¹å¼
   115â†’        switch strategy {
   116â†’        case .ultraLowMemory:
   117â†’            // æç«¯å†…å­˜ä¸è¶³ï¼šæœ€æ¿€è¿›å‹ç¼©
   118â†’            print("ğŸš¨ æç«¯å†…å­˜æ¨¡å¼")
   119â†’            return createUltraDownsampledImage(from: imageData, maxPixels: maxPixels)
   120â†’            
   121â†’        case .lowMemory:
   122â†’            // å†…å­˜ç´§å¼ ï¼šæ¿€è¿›å‹ç¼©
   123â†’            print("âš¡ ä½å†…å­˜æ¨¡å¼")
   124â†’            if pixelCount > maxPixels {
   125â†’                return createDownsampledImage(from: imageData, maxPixels: maxPixels)
   126â†’            } else {
   127â†’                return UIImage(data: imageData)
   128â†’            }
   129â†’            
   130â†’        case .standard:
   131â†’            // å†…å­˜å……è¶³ï¼šæ ‡å‡†å¤„ç†
   132â†’            print("âœ… æ ‡å‡†æ¨¡å¼")
   133â†’            return createOptimizedUIImage(from: imageData, pixelCount: pixelCount)
   134â†’        }
   135â†’    }
   136â†’    
   137â†’    // åˆ›å»ºå†…å­˜ä¼˜åŒ–çš„UIImage - æç«¯ä¼˜åŒ–ç‰ˆæœ¬
   138â†’    private func createOptimizedUIImage(from imageData: Data, pixelCount: Int) -> UIImage? {
   139â†’        // æ›´æ¿€è¿›çš„å†…å­˜æ§åˆ¶ç­–ç•¥
   140â†’        if pixelCount > 48_000_000 { // 48MP - æç«¯å‹ç¼©
   141â†’            print("ğŸš¨ æ£€æµ‹åˆ°48MPå›¾åƒï¼Œå¯ç”¨æç«¯å†…å­˜ä¼˜åŒ–")
   142â†’            return createUltraDownsampledImage(from: imageData, maxPixels: 8_000_000) // é™è‡³8MP
   143â†’        } else if pixelCount > 20_000_000 { // 20MP+ - æ¿€è¿›å‹ç¼©
   144â†’            print("âš¡ æ£€æµ‹åˆ°å¤§å›¾åƒï¼Œå¯ç”¨æ¿€è¿›å†…å­˜ä¼˜åŒ–")
   145â†’            return createDownsampledImage(from: imageData, maxPixels: 12_000_000) // é™è‡³12MP
   146â†’        } else if pixelCount > 10_000_000 { // 10MP+ - é€‚åº¦å‹ç¼©
   147â†’            return createDownsampledImage(from: imageData, maxPixels: 8_000_000) // é™è‡³8MP
   148â†’        } else {
   149â†’            // å°å›¾åƒç›´æ¥åˆ›å»º
   150â†’            return UIImage(data: imageData)
   151â†’        }
   152â†’    }
   153â†’    
   154â†’    // æç«¯é™é‡‡æ ·å›¾åƒï¼ˆç”¨äº48MPç­‰è¶…å¤§å›¾åƒï¼‰
   155â†’    private func createUltraDownsampledImage(from imageData: Data, maxPixels: Int) -> UIImage? {
   156â†’        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }
   157â†’        
   158â†’        // ä½¿ç”¨æœ€å°å†…å­˜é…ç½®
   159â†’        let options: [CFString: Any] = [
   160â†’            kCGImageSourceCreateThumbnailFromImageAlways: true,
   161â†’            kCGImageSourceCreateThumbnailWithTransform: true,
   162â†’            kCGImageSourceThumbnailMaxPixelSize: Int(sqrt(Double(maxPixels))), // æ›´ä¿å®ˆçš„å°ºå¯¸è®¡ç®—
   163â†’            kCGImageSourceShouldCache: false, // ç¦ç”¨ç¼“å­˜
   164â†’            kCGImageSourceShouldAllowFloat: false // ç¦ç”¨æµ®ç‚¹æ•°å¤„ç†
   165â†’        ]
   166â†’        
   167â†’        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else { return nil }
   168â†’        
   169â†’        let finalWidth = downsampledImage.width
   170â†’        let finalHeight = downsampledImage.height
   171â†’        let finalPixels = finalWidth * finalHeight
   172â†’        
   173â†’        print("ğŸ”¥ æç«¯é™é‡‡æ ·å®Œæˆ: \(finalWidth)Ã—\(finalHeight) (\(finalPixels/1_000_000)MP)")
   174â†’        
   175â†’        return UIImage(cgImage: downsampledImage)
   176â†’    }
   177â†’    
   178â†’    // æ ‡å‡†é™é‡‡æ ·å›¾åƒ
   179â†’    private func createDownsampledImage(from imageData: Data, maxPixels: Int) -> UIImage? {
   180â†’        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }
   181â†’        
   182â†’        // è·å–åŸå§‹å°ºå¯¸
   183â†’        guard let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
   184â†’              let originalWidth = properties[kCGImagePropertyPixelWidth as String] as? Int,
   185â†’              let originalHeight = properties[kCGImagePropertyPixelHeight as String] as? Int else { return nil }
   186â†’        
   187â†’        // è®¡ç®—é™é‡‡æ ·æ¯”ä¾‹
   188â†’        let originalPixels = originalWidth * originalHeight
   189â†’        let scale = sqrt(Double(maxPixels) / Double(originalPixels))
   190â†’        
   191â†’        let targetSize = Int(Double(max(originalWidth, originalHeight)) * scale)
   192â†’        
   193â†’        print("ğŸ“‰ æ ‡å‡†é™é‡‡æ ·: \(originalWidth)Ã—\(originalHeight) -> æœ€å¤§è¾¹é•¿\(targetSize)")
   194â†’        
   195â†’        // åˆ›å»ºé™é‡‡æ ·é€‰é¡¹
   196â†’        let options: [CFString: Any] = [
   197â†’            kCGImageSourceCreateThumbnailFromImageAlways: true,
   198â†’            kCGImageSourceCreateThumbnailWithTransform: true,
   199â†’            kCGImageSourceThumbnailMaxPixelSize: targetSize,
   200â†’            kCGImageSourceShouldCache: false // ç¦ç”¨ç¼“å­˜å‡å°‘å†…å­˜ä½¿ç”¨
   201â†’        ]
   202â†’        
   203â†’        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else { return nil }
   204â†’        
   205â†’        return UIImage(cgImage: downsampledImage)
   206â†’    }
   207â†’    
   208â†’    // ä»å›¾åƒæ•°æ®ä¸­æå–å…ƒæ•°æ® - ä¼˜åŒ–ç‰ˆæœ¬
   209â†’    private func getMetadataFromImageData(_ imageData: Data) -> [String: Any] {
   210â†’        var metadata: [String: Any] = [:]
   211â†’        
   212â†’        // ä½¿ç”¨autoreleasepoolå‡å°‘å†…å­˜å ç”¨
   213â†’        autoreleasepool {
   214â†’            if let source = CGImageSourceCreateWithData(imageData as CFData, nil) {
   215â†’                // åªè·å–éœ€è¦çš„å…ƒæ•°æ®ï¼Œé¿å…å¤åˆ¶æ•´ä¸ªå…ƒæ•°æ®å­—å…¸
   216â†’                if let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any] {
   217â†’                    // æå–EXIFä¿¡æ¯
   218â†’                    if let exif = properties[kCGImagePropertyExifDictionary as String] as? [String: Any] {
   219â†’                        // åªå¤åˆ¶éœ€è¦çš„EXIFå­—æ®µ
   220â†’                        var exifSubset: [String: Any] = [:]
   221â†’                        
   222â†’                        // ISO
   223â†’                        if let iso = exif[kCGImagePropertyExifISOSpeedRatings as String] {
   224â†’                            exifSubset[kCGImagePropertyExifISOSpeedRatings as String] = iso
   225â†’                        }
   226â†’                        
   227â†’                        // å…‰åœˆ
   228â†’                        if let aperture = exif[kCGImagePropertyExifFNumber as String] {
   229â†’                            exifSubset[kCGImagePropertyExifFNumber as String] = aperture
   230â†’                        }
   231â†’                        
   232â†’                        // å¿«é—¨é€Ÿåº¦
   233â†’                        if let shutterSpeed = exif[kCGImagePropertyExifExposureTime as String] {
   234â†’                            exifSubset[kCGImagePropertyExifExposureTime as String] = shutterSpeed
   235â†’                        }
   236â†’                        
   237â†’                        // ç„¦è·
   238â†’                        if let focalLength = exif[kCGImagePropertyExifFocalLength as String] {
   239â†’                            exifSubset[kCGImagePropertyExifFocalLength as String] = focalLength
   240â†’                        }
   241â†’                        
   242â†’                        // æ—¥æœŸæ—¶é—´
   243â†’                        if let dateTime = exif[kCGImagePropertyExifDateTimeOriginal as String] {
   244â†’                            exifSubset[kCGImagePropertyExifDateTimeOriginal as String] = dateTime
   245â†’                        }
   246â†’                        
   247â†’                        metadata["exif"] = exifSubset
   248â†’                    }
   249â†’                    
   250â†’                    // æå–TIFFä¿¡æ¯
   251â†’                    if let tiff = properties[kCGImagePropertyTIFFDictionary as String] as? [String: Any] {
   252â†’                        // åªå¤åˆ¶éœ€è¦çš„TIFFå­—æ®µ
   253â†’                        var tiffSubset: [String: Any] = [:]
   254â†’                        
   255â†’                        // åˆ¶é€ å•†
   256â†’                        if let make = tiff[kCGImagePropertyTIFFMake as String] {
   257â†’                            tiffSubset[kCGImagePropertyTIFFMake as String] = make
   258â†’                        }
   259â†’                        
   260â†’                        // å‹å·
   261â†’                        if let model = tiff[kCGImagePropertyTIFFModel as String] {
   262â†’                            tiffSubset[kCGImagePropertyTIFFModel as String] = model
   263â†’                        }
   264â†’                        
   265â†’                        metadata["tiff"] = tiffSubset
   266â†’                    }
   267â†’                    
   268â†’                    // æå–GPSä¿¡æ¯
   269â†’                    if let gps = properties[kCGImagePropertyGPSDictionary as String] as? [String: Any] {
   270â†’                        // åªå¤åˆ¶éœ€è¦çš„GPSå­—æ®µ
   271â†’                        var gpsSubset: [String: Any] = [:]
   272â†’                        
   273â†’                        // çº¬åº¦
   274â†’                        if let latitude = gps[kCGImagePropertyGPSLatitude as String] {
   275â†’                            gpsSubset[kCGImagePropertyGPSLatitude as String] = latitude
   276â†’                        }
   277â†’                        
   278â†’                        // çº¬åº¦å‚è€ƒ
   279â†’                        if let latitudeRef = gps[kCGImagePropertyGPSLatitudeRef as String] {
   280â†’                            gpsSubset[kCGImagePropertyGPSLatitudeRef as String] = latitudeRef
   281â†’                        }
   282â†’                        
   283â†’                        // ç»åº¦
   284â†’                        if let longitude = gps[kCGImagePropertyGPSLongitude as String] {
   285â†’                            gpsSubset[kCGImagePropertyGPSLongitude as String] = longitude
   286â†’                        }
   287â†’                        
   288â†’                        // ç»åº¦å‚è€ƒ
   289â†’                        if let longitudeRef = gps[kCGImagePropertyGPSLongitudeRef as String] {
   290â†’                            gpsSubset[kCGImagePropertyGPSLongitudeRef as String] = longitudeRef
   291â†’                        }
   292â†’                        
   293â†’                        metadata["gps"] = gpsSubset
   294â†’                    }
   295â†’                }
   296â†’            }
   297â†’        }
   298â†’        
   299â†’        return metadata
   300â†’    }
   301â†’}
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Features/Frame/Services/OptimizedPhotoDecorationRenderer.swift`

Result:

```
1â†’import UIKit
     2â†’import CoreLocation
     3â†’
     4â†’class OptimizedPhotoDecorationRenderer {
     5â†’    
     6â†’    // å†…å­˜ä¼˜åŒ–é…ç½® - æ›´æ¿€è¿›çš„è®¾ç½®
     7â†’    private let maxRenderSize: CGFloat = 1536 // è¿›ä¸€æ­¥é™ä½æ¸²æŸ“å°ºå¯¸ä»¥å‡å°‘å†…å­˜
     8â†’    private let memoryPressureThreshold: Int = 15_000_000 // 15MPä»¥ä¸Šä½¿ç”¨ç‰¹æ®Šä¼˜åŒ–ï¼ˆæ›´ä½é˜ˆå€¼ï¼‰
     9â†’    
    10â†’    // æ¸²æŸ“è£…é¥°åˆ°ç…§ç‰‡ä¸Š - å†…å­˜ä¼˜åŒ–ç‰ˆæœ¬
    11â†’    func renderDecoration(
    12â†’        on image: UIImage,
    13â†’        frameType: FrameType,
    14â†’        customText: String,
    15â†’        showDate: Bool,
    16â†’        showLocation: Bool,
    17â†’        showExif: Bool,
    18â†’        showExifParams: Bool,
    19â†’        showExifDate: Bool,
    20â†’        selectedLogo: String?,
    21â†’        showSignature: Bool,
    22â†’        metadata: [String: Any]
    23â†’    ) -> UIImage {
    24â†’        
    25â†’        let originalSize = image.size
    26â†’        let pixelCount = Int(originalSize.width * originalSize.height)
    27â†’        
    28â†’        // å¯¹äºè¶…å¤§å›¾åƒä½¿ç”¨ç‰¹æ®Šä¼˜åŒ–ç­–ç•¥
    29â†’        if pixelCount > memoryPressureThreshold {
    30â†’            return renderLargeImageWithTiling(
    31â†’                image: image,
    32â†’                frameType: frameType,
    33â†’                customText: customText,
    34â†’                showDate: showDate,
    35â†’                showLocation: showLocation,
    36â†’                showExif: showExif,
    37â†’                showExifParams: showExifParams,
    38â†’                showExifDate: showExifDate,
    39â†’                selectedLogo: selectedLogo,
    40â†’                showSignature: showSignature,
    41â†’                metadata: metadata
    42â†’            )
    43â†’        } else {
    44â†’            return renderStandardImage(
    45â†’                image: image,
    46â†’                frameType: frameType,
    47â†’                customText: customText,
    48â†’                showDate: showDate,
    49â†’                showLocation: showLocation,
    50â†’                showExif: showExif,
    51â†’                showExifParams: showExifParams,
    52â†’                showExifDate: showExifDate,
    53â†’                selectedLogo: selectedLogo,
    54â†’                showSignature: showSignature,
    55â†’                metadata: metadata
    56â†’            )
    57â†’        }
    58â†’    }
    59â†’    
    60â†’    // æ ‡å‡†å›¾åƒæ¸²æŸ“ï¼ˆå†…å­˜ä¼˜åŒ–ï¼‰
    61â†’    private func renderStandardImage(
    62â†’        image: UIImage,
    63â†’        frameType: FrameType,
    64â†’        customText: String,
    65â†’        showDate: Bool,
    66â†’        showLocation: Bool,
    67â†’        showExif: Bool,
    68â†’        showExifParams: Bool,
    69â†’        showExifDate: Bool,
    70â†’        selectedLogo: String?,
    71â†’        showSignature: Bool,
    72â†’        metadata: [String: Any]
    73â†’    ) -> UIImage {
    74â†’        
    75â†’        var result: UIImage?
    76â†’        
    77â†’        autoreleasepool {
    78â†’            guard let cgImage = image.cgImage else {
    79â†’                result = image
    80â†’                return
    81â†’            }
    82â†’            
    83â†’            let size = CGSize(width: cgImage.width, height: cgImage.height)
    84â†’            let colorSpace = CGColorSpaceCreateDeviceRGB()
    85â†’            
    86â†’            // ä½¿ç”¨Core Graphics Contextæ›¿ä»£UIGraphics
    87â†’            guard let context = CGContext(
    88â†’                data: nil,
    89â†’                width: Int(size.width),
    90â†’                height: Int(size.height),
    91â†’                bitsPerComponent: 8,
    92â†’                bytesPerRow: 0,
    93â†’                space: colorSpace,
    94â†’                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
    95â†’            ) else {
    96â†’                result = image
    97â†’                return
    98â†’            }
    99â†’            
   100â†’            // è®¾ç½®é«˜è´¨é‡æ¸²æŸ“
   101â†’            context.interpolationQuality = .high
   102â†’            
   103â†’            // ç»˜åˆ¶åŸå§‹å›¾åƒ
   104â†’            context.draw(cgImage, in: CGRect(origin: .zero, size: size))
   105â†’            
   106â†’            // æ ¹æ®ç›¸æ¡†ç±»å‹åº”ç”¨è£…é¥°
   107â†’            switch frameType {
   108â†’            case .bottomText:
   109â†’                renderBottomTextFrameCG(
   110â†’                    context: context,
   111â†’                    imageSize: size,
   112â†’                    customText: customText,
   113â†’                    showDate: showDate,
   114â†’                    showLocation: showLocation,
   115â†’                    showExif: showExif,
   116â†’                    showExifParams: showExifParams,
   117â†’                    showExifDate: showExifDate,
   118â†’                    selectedLogo: selectedLogo,
   119â†’                    showSignature: showSignature,
   120â†’                    metadata: metadata
   121â†’                )
   122â†’                
   123â†’            case .centerWatermark:
   124â†’                renderCenterWatermarkFrameCG(
   125â†’                    context: context,
   126â†’                    imageSize: size,
   127â†’                    customText: customText,
   128â†’                    selectedLogo: selectedLogo,
   129â†’                    metadata: metadata
   130â†’                )
   131â†’                
   132â†’            case .magazineCover:
   133â†’                renderMagazineCoverFrameCG(
   134â†’                    context: context,
   135â†’                    imageSize: size,
   136â†’                    customText: customText,
   137â†’                    showDate: showDate,
   138â†’                    selectedLogo: selectedLogo,
   139â†’                    metadata: metadata
   140â†’                )
   141â†’                
   142â†’            case .polaroid:
   143â†’                renderPolaroidFrameCG(
   144â†’                    context: context,
   145â†’                    imageSize: size,
   146â†’                    customText: customText,
   147â†’                    showDate: showDate,
   148â†’                    metadata: metadata
   149â†’                )
   150â†’                
   151â†’            case .none:
   152â†’                break
   153â†’            }
   154â†’            
   155â†’            // è·å–æœ€ç»ˆå›¾åƒ
   156â†’            if let finalCGImage = context.makeImage() {
   157â†’                result = UIImage(cgImage: finalCGImage, scale: image.scale, orientation: image.imageOrientation)
   158â†’            } else {
   159â†’                result = image
   160â†’            }
   161â†’        }
   162â†’        
   163â†’        return result ?? image
   164â†’    }
   165â†’    
   166â†’    // å¤§å›¾åƒç“¦ç‰‡åŒ–æ¸²æŸ“
   167â†’    private func renderLargeImageWithTiling(
   168â†’        image: UIImage,
   169â†’        frameType: FrameType,
   170â†’        customText: String,
   171â†’        showDate: Bool,
   172â†’        showLocation: Bool,
   173â†’        showExif: Bool,
   174â†’        showExifParams: Bool,
   175â†’        showExifDate: Bool,
   176â†’        selectedLogo: String?,
   177â†’        showSignature: Bool,
   178â†’        metadata: [String: Any]
   179â†’    ) -> UIImage {
   180â†’        
   181â†’        print("ğŸš€ ä½¿ç”¨ç“¦ç‰‡åŒ–æ¸²æŸ“å¤„ç†å¤§å›¾åƒ...")
   182â†’        
   183â†’        var result: UIImage?
   184â†’        
   185â†’        autoreleasepool {
   186â†’            guard let cgImage = image.cgImage else {
   187â†’                result = image
   188â†’                return
   189â†’            }
   190â†’            
   191â†’            let originalSize = CGSize(width: cgImage.width, height: cgImage.height)
   192â†’            
   193â†’            // è®¡ç®—ç¼©æ”¾å› å­ - æ›´æ¿€è¿›çš„ç¼©å°ç­–ç•¥
   194â†’            let targetRenderSize = min(maxRenderSize, 1200) // è¿›ä¸€æ­¥é™åˆ¶æœ€å¤§å°ºå¯¸
   195â†’            let scaleFactor = min(targetRenderSize / originalSize.width, targetRenderSize / originalSize.height, 0.5) // æœ€å¤šåªèƒ½æ˜¯åŸå°ºå¯¸çš„50%
   196â†’            let renderSize = CGSize(
   197â†’                width: originalSize.width * scaleFactor,
   198â†’                height: originalSize.height * scaleFactor
   199â†’            )
   200â†’            
   201â†’            print("ğŸ“ åŸå§‹å°ºå¯¸: \(Int(originalSize.width))Ã—\(Int(originalSize.height))")
   202â†’            print("ğŸ“ æ¸²æŸ“å°ºå¯¸: \(Int(renderSize.width))Ã—\(Int(renderSize.height))")
   203â†’            print("ğŸ“ ç¼©æ”¾å› å­: \(scaleFactor)")
   204â†’            
   205â†’            // ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºç¼©å°çš„æ¸²æŸ“ç‰ˆæœ¬
   206â†’            let scaledImage = createScaledImage(from: cgImage, size: renderSize)
   207â†’            
   208â†’            // ç¬¬äºŒæ­¥ï¼šåœ¨å°å›¾ä¸Šæ¸²æŸ“è£…é¥°
   209â†’            let decoratedSmallImage = renderStandardImage(
   210â†’                image: UIImage(cgImage: scaledImage),
   211â†’                frameType: frameType,
   212â†’                customText: customText,
   213â†’                showDate: showDate,
   214â†’                showLocation: showLocation,
   215â†’                showExif: showExif,
   216â†’                showExifParams: showExifParams,
   217â†’                showExifDate: showExifDate,
   218â†’                selectedLogo: selectedLogo,
   219â†’                showSignature: showSignature,
   220â†’                metadata: metadata
   221â†’            )
   222â†’            
   223â†’            // ç¬¬ä¸‰æ­¥ï¼šå°†è£…é¥°åçš„å›¾åƒæ”¾å¤§å›åŸå§‹å°ºå¯¸
   224â†’            if let decoratedCGImage = decoratedSmallImage.cgImage {
   225â†’                let finalImage = createScaledImage(from: decoratedCGImage, size: originalSize)
   226â†’                result = UIImage(cgImage: finalImage, scale: image.scale, orientation: image.imageOrientation)
   227â†’            } else {
   228â†’                result = image
   229â†’            }
   230â†’        }
   231â†’        
   232â†’        print("âœ… ç“¦ç‰‡åŒ–æ¸²æŸ“å®Œæˆ")
   233â†’        return result ?? image
   234â†’    }
   235â†’    
   236â†’    // åˆ›å»ºç¼©æ”¾å›¾åƒï¼ˆå†…å­˜ä¼˜åŒ–ç‰ˆï¼‰
   237â†’    private func createScaledImage(from cgImage: CGImage, size: CGSize) -> CGImage {
   238â†’        autoreleasepool {
   239â†’            let colorSpace = CGColorSpaceCreateDeviceRGB()
   240â†’            
   241â†’            guard let context = CGContext(
   242â†’                data: nil,
   243â†’                width: Int(size.width),
   244â†’                height: Int(size.height),
   245â†’                bitsPerComponent: 8,
   246â†’                bytesPerRow: 0,
   247â†’                space: colorSpace,
   248â†’                bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
   249â†’            ) else {
   250â†’                return cgImage
   251â†’            }
   252â†’            
   253â†’            context.interpolationQuality = .high
   254â†’            context.draw(cgImage, in: CGRect(origin: .zero, size: size))
   255â†’            
   256â†’            return context.makeImage() ?? cgImage
   257â†’        }
   258â†’    }
   259â†’    
   260â†’    // Core Graphicsç‰ˆæœ¬çš„åº•éƒ¨æ–‡å­—ç›¸æ¡†æ¸²æŸ“
   261â†’    private func renderBottomTextFrameCG(
   262â†’        context: CGContext,
   263â†’        imageSize: CGSize,
   264â†’        customText: String,
   265â†’        showDate: Bool,
   266â†’        showLocation: Bool,
   267â†’        showExif: Bool,
   268â†’        showExifParams: Bool,
   269â†’        showExifDate: Bool,
   270â†’        selectedLogo: String?,
   271â†’        showSignature: Bool,
   272â†’        metadata: [String: Any]
   273â†’    ) {
   274â†’        // åº•éƒ¨é»‘è‰²æ¡
   275â†’        let barHeight = imageSize.height * 0.08
   276â†’        let barRect = CGRect(x: 0, y: imageSize.height - barHeight, width: imageSize.width, height: barHeight)
   277â†’        
   278â†’        context.setFillColor(UIColor.black.cgColor)
   279â†’        context.fill(barRect)
   280â†’        
   281â†’        // ç»˜åˆ¶è‡ªå®šä¹‰æ–‡å­—
   282â†’        if !customText.isEmpty {
   283â†’            let fontSize = barHeight * 0.4
   284â†’            let font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
   285â†’            
   286â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   287â†’                .font: font,
   288â†’                .foregroundColor: UIColor.white
   289â†’            ]
   290â†’            
   291â†’            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   292â†’            let textSize = attributedString.size()
   293â†’            
   294â†’            let textRect = CGRect(
   295â†’                x: imageSize.width / 2 - textSize.width / 2,
   296â†’                y: imageSize.height - barHeight / 2 - textSize.height / 2,
   297â†’                width: textSize.width,
   298â†’                height: textSize.height
   299â†’            )
   300â†’            
   301â†’            // ä½¿ç”¨Core Textç»˜åˆ¶æ–‡å­—
   302â†’            let line = CTLineCreateWithAttributedString(attributedString)
   303â†’            context.saveGState()
   304â†’            context.textMatrix = .identity
   305â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   306â†’            context.scaleBy(x: 1, y: -1) // ç¿»è½¬Yè½´
   307â†’            CTLineDraw(line, context)
   308â†’            context.restoreGState()
   309â†’        }
   310â†’        
   311â†’        // ç»˜åˆ¶æ—¥æœŸ
   312â†’        if showDate {
   313â†’            let dateFormatter = DateFormatter()
   314â†’            dateFormatter.dateFormat = "yyyy-MM-dd"
   315â†’            let dateString = dateFormatter.string(from: Date())
   316â†’            
   317â†’            let fontSize = barHeight * 0.3
   318â†’            let font = UIFont.systemFont(ofSize: fontSize, weight: .regular)
   319â†’            
   320â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   321â†’                .font: font,
   322â†’                .foregroundColor: UIColor.white
   323â†’            ]
   324â†’            
   325â†’            let attributedString = NSAttributedString(string: dateString, attributes: textAttributes)
   326â†’            let textSize = attributedString.size()
   327â†’            
   328â†’            let textRect = CGRect(
   329â†’                x: imageSize.width - textSize.width - 20,
   330â†’                y: imageSize.height - barHeight / 2 - textSize.height / 2,
   331â†’                width: textSize.width,
   332â†’                height: textSize.height
   333â†’            )
   334â†’            
   335â†’            let line = CTLineCreateWithAttributedString(attributedString)
   336â†’            context.saveGState()
   337â†’            context.textMatrix = .identity
   338â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   339â†’            context.scaleBy(x: 1, y: -1)
   340â†’            CTLineDraw(line, context)
   341â†’            context.restoreGState()
   342â†’        }
   343â†’        
   344â†’        // ç»˜åˆ¶Logo
   345â†’        if let logoName = selectedLogo {
   346â†’            let logoSize = barHeight * 0.7
   347â†’            if let logoImage = getOptimizedLogoImage(logoName, maxSize: logoSize) {
   348â†’                let logoRect = CGRect(
   349â†’                    x: 20,
   350â†’                    y: imageSize.height - barHeight / 2 - logoSize / 2,
   351â†’                    width: logoSize,
   352â†’                    height: logoSize
   353â†’                )
   354â†’                
   355â†’                context.draw(logoImage, in: logoRect)
   356â†’            }
   357â†’        }
   358â†’        
   359â†’        // ç»˜åˆ¶EXIFä¿¡æ¯
   360â†’        if showExif && showExifParams {
   361â†’            var exifText = ""
   362â†’            
   363â†’            if let exif = metadata["exif"] as? [String: Any] {
   364â†’                if let iso = exif[kCGImagePropertyExifISOSpeedRatings as String] as? [NSNumber], let isoValue = iso.first {
   365â†’                    exifText += "ISO \(isoValue) "
   366â†’                }
   367â†’                
   368â†’                if let aperture = exif[kCGImagePropertyExifFNumber as String] as? NSNumber {
   369â†’                    exifText += "f/\(aperture) "
   370â†’                }
   371â†’                
   372â†’                if let shutterSpeed = exif[kCGImagePropertyExifExposureTime as String] as? NSNumber {
   373â†’                    let shutterValue = 1.0 / shutterSpeed.doubleValue
   374â†’                    exifText += "1/\(Int(shutterValue))s "
   375â†’                }
   376â†’            }
   377â†’            
   378â†’            if !exifText.isEmpty {
   379â†’                let fontSize = barHeight * 0.25
   380â†’                let font = UIFont.systemFont(ofSize: fontSize, weight: .regular)
   381â†’                
   382â†’                let textAttributes: [NSAttributedString.Key: Any] = [
   383â†’                    .font: font,
   384â†’                    .foregroundColor: UIColor.white
   385â†’                ]
   386â†’                
   387â†’                let attributedString = NSAttributedString(string: exifText, attributes: textAttributes)
   388â†’                let textSize = attributedString.size()
   389â†’                
   390â†’                let textRect = CGRect(
   391â†’                    x: 20,
   392â†’                    y: imageSize.height - barHeight + 5,
   393â†’                    width: textSize.width,
   394â†’                    height: textSize.height
   395â†’                )
   396â†’                
   397â†’                let line = CTLineCreateWithAttributedString(attributedString)
   398â†’                context.saveGState()
   399â†’                context.textMatrix = .identity
   400â†’                context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   401â†’                context.scaleBy(x: 1, y: -1)
   402â†’                CTLineDraw(line, context)
   403â†’                context.restoreGState()
   404â†’            }
   405â†’        }
   406â†’    }
   407â†’    
   408â†’    // Core Graphicsç‰ˆæœ¬çš„ä¸­å¿ƒæ°´å°æ¸²æŸ“
   409â†’    private func renderCenterWatermarkFrameCG(
   410â†’        context: CGContext,
   411â†’        imageSize: CGSize,
   412â†’        customText: String,
   413â†’        selectedLogo: String?,
   414â†’        metadata: [String: Any]
   415â†’    ) {
   416â†’        // ç»˜åˆ¶åŠé€æ˜Logo
   417â†’        if let logoName = selectedLogo {
   418â†’            let logoSize = min(imageSize.width, imageSize.height) * 0.2
   419â†’            if let logoImage = getOptimizedLogoImage(logoName, maxSize: logoSize) {
   420â†’                let logoRect = CGRect(
   421â†’                    x: imageSize.width / 2 - logoSize / 2,
   422â†’                    y: imageSize.height / 2 - logoSize / 2,
   423â†’                    width: logoSize,
   424â†’                    height: logoSize
   425â†’                )
   426â†’                
   427â†’                context.saveGState()
   428â†’                context.setAlpha(0.3)
   429â†’                context.draw(logoImage, in: logoRect)
   430â†’                context.restoreGState()
   431â†’            }
   432â†’        }
   433â†’        
   434â†’        // ç»˜åˆ¶è‡ªå®šä¹‰æ–‡å­—
   435â†’        if !customText.isEmpty {
   436â†’            let fontSize = min(imageSize.width, imageSize.height) * 0.03
   437â†’            let font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
   438â†’            
   439â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   440â†’                .font: font,
   441â†’                .foregroundColor: UIColor.white.withAlphaComponent(0.7)
   442â†’            ]
   443â†’            
   444â†’            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   445â†’            let textSize = attributedString.size()
   446â†’            
   447â†’            let textRect = CGRect(
   448â†’                x: imageSize.width / 2 - textSize.width / 2,
   449â†’                y: imageSize.height / 2 + min(imageSize.width, imageSize.height) * 0.12,
   450â†’                width: textSize.width,
   451â†’                height: textSize.height
   452â†’            )
   453â†’            
   454â†’            // æ·»åŠ æ–‡å­—èƒŒæ™¯
   455â†’            let backgroundRect = textRect.insetBy(dx: -10, dy: -5)
   456â†’            context.setFillColor(UIColor.black.withAlphaComponent(0.3).cgColor)
   457â†’            context.fill(backgroundRect)
   458â†’            
   459â†’            // ç»˜åˆ¶æ–‡å­—
   460â†’            let line = CTLineCreateWithAttributedString(attributedString)
   461â†’            context.saveGState()
   462â†’            context.textMatrix = .identity
   463â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   464â†’            context.scaleBy(x: 1, y: -1)
   465â†’            CTLineDraw(line, context)
   466â†’            context.restoreGState()
   467â†’        }
   468â†’    }
   469â†’    
   470â†’    // Core Graphicsç‰ˆæœ¬çš„æ‚å¿—å°é¢æ¸²æŸ“
   471â†’    private func renderMagazineCoverFrameCG(
   472â†’        context: CGContext,
   473â†’        imageSize: CGSize,
   474â†’        customText: String,
   475â†’        showDate: Bool,
   476â†’        selectedLogo: String?,
   477â†’        metadata: [String: Any]
   478â†’    ) {
   479â†’        // é¡¶éƒ¨é»‘è‰²æ¡
   480â†’        let topBarHeight = imageSize.height * 0.1
   481â†’        let topBarRect = CGRect(x: 0, y: 0, width: imageSize.width, height: topBarHeight)
   482â†’        context.setFillColor(UIColor.black.cgColor)
   483â†’        context.fill(topBarRect)
   484â†’        
   485â†’        // åº•éƒ¨é»‘è‰²æ¡
   486â†’        let bottomBarHeight = imageSize.height * 0.05
   487â†’        let bottomBarRect = CGRect(x: 0, y: imageSize.height - bottomBarHeight, width: imageSize.width, height: bottomBarHeight)
   488â†’        context.setFillColor(UIColor.black.cgColor)
   489â†’        context.fill(bottomBarRect)
   490â†’        
   491â†’        // ç»˜åˆ¶Logo
   492â†’        if let logoName = selectedLogo {
   493â†’            let logoHeight = topBarHeight * 0.6
   494â†’            if let logoImage = getOptimizedLogoImage(logoName, maxSize: logoHeight) {
   495â†’                let logoWidth = logoHeight * (CGFloat(logoImage.width) / CGFloat(logoImage.height))
   496â†’                let logoRect = CGRect(
   497â†’                    x: 20,
   498â†’                    y: topBarHeight / 2 - logoHeight / 2,
   499â†’                    width: logoWidth,
   500â†’                    height: logoHeight
   501â†’                )
   502â†’                
   503â†’                context.draw(logoImage, in: logoRect)
   504â†’            }
   505â†’        }
   506â†’        
   507â†’        // ç»˜åˆ¶æ ‡é¢˜
   508â†’        if !customText.isEmpty {
   509â†’            let fontSize = topBarHeight * 0.4
   510â†’            let font = UIFont.systemFont(ofSize: fontSize, weight: .bold)
   511â†’            
   512â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   513â†’                .font: font,
   514â†’                .foregroundColor: UIColor.white
   515â†’            ]
   516â†’            
   517â†’            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   518â†’            let textSize = attributedString.size()
   519â†’            
   520â†’            let textRect = CGRect(
   521â†’                x: imageSize.width - textSize.width - 20,
   522â†’                y: topBarHeight / 2 - textSize.height / 2,
   523â†’                width: textSize.width,
   524â†’                height: textSize.height
   525â†’            )
   526â†’            
   527â†’            let line = CTLineCreateWithAttributedString(attributedString)
   528â†’            context.saveGState()
   529â†’            context.textMatrix = .identity
   530â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   531â†’            context.scaleBy(x: 1, y: -1)
   532â†’            CTLineDraw(line, context)
   533â†’            context.restoreGState()
   534â†’        }
   535â†’        
   536â†’        // ç»˜åˆ¶æ—¥æœŸ
   537â†’        if showDate {
   538â†’            let dateFormatter = DateFormatter()
   539â†’            dateFormatter.dateFormat = "yyyyå¹´MMæœˆ"
   540â†’            let dateString = dateFormatter.string(from: Date())
   541â†’            
   542â†’            let fontSize = bottomBarHeight * 0.6
   543â†’            let font = UIFont.systemFont(ofSize: fontSize, weight: .medium)
   544â†’            
   545â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   546â†’                .font: font,
   547â†’                .foregroundColor: UIColor.white
   548â†’            ]
   549â†’            
   550â†’            let attributedString = NSAttributedString(string: dateString, attributes: textAttributes)
   551â†’            let textSize = attributedString.size()
   552â†’            
   553â†’            let textRect = CGRect(
   554â†’                x: imageSize.width / 2 - textSize.width / 2,
   555â†’                y: imageSize.height - bottomBarHeight / 2 - textSize.height / 2,
   556â†’                width: textSize.width,
   557â†’                height: textSize.height
   558â†’            )
   559â†’            
   560â†’            let line = CTLineCreateWithAttributedString(attributedString)
   561â†’            context.saveGState()
   562â†’            context.textMatrix = .identity
   563â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   564â†’            context.scaleBy(x: 1, y: -1)
   565â†’            CTLineDraw(line, context)
   566â†’            context.restoreGState()
   567â†’        }
   568â†’    }
   569â†’    
   570â†’    // Core Graphicsç‰ˆæœ¬çš„å®ä¸½æ¥ç›¸æ¡†æ¸²æŸ“
   571â†’    private func renderPolaroidFrameCG(
   572â†’        context: CGContext,
   573â†’        imageSize: CGSize,
   574â†’        customText: String,
   575â†’        showDate: Bool,
   576â†’        metadata: [String: Any]
   577â†’    ) {
   578â†’        // è®¡ç®—å®ä¸½æ¥ç›¸æ¡†çš„å°ºå¯¸å’Œä½ç½®
   579â†’        let borderWidth: CGFloat = min(imageSize.width, imageSize.height) * 0.05
   580â†’        let bottomBorderHeight: CGFloat = min(imageSize.width, imageSize.height) * 0.15
   581â†’        
   582â†’        // ç»˜åˆ¶ç™½è‰²èƒŒæ™¯æ¡†
   583â†’        let frameRect = CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height)
   584â†’        context.setFillColor(UIColor.white.cgColor)
   585â†’        context.fill(frameRect)
   586â†’        
   587â†’        // ç»˜åˆ¶ç…§ç‰‡åŒºåŸŸé˜´å½±æ•ˆæœ
   588â†’        let photoRect = CGRect(
   589â†’            x: borderWidth,
   590â†’            y: borderWidth,
   591â†’            width: imageSize.width - borderWidth * 2,
   592â†’            height: imageSize.height - borderWidth - bottomBorderHeight
   593â†’        )
   594â†’        
   595â†’        context.setFillColor(UIColor.black.withAlphaComponent(0.1).cgColor)
   596â†’        context.fill(photoRect)
   597â†’        
   598â†’        // ç»˜åˆ¶è‡ªå®šä¹‰æ–‡å­—
   599â†’        if !customText.isEmpty {
   600â†’            let fontSize = bottomBorderHeight * 0.4
   601â†’            let font = UIFont(name: "Marker Felt", size: fontSize) ?? UIFont.systemFont(ofSize: fontSize, weight: .medium)
   602â†’            
   603â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   604â†’                .font: font,
   605â†’                .foregroundColor: UIColor.black
   606â†’            ]
   607â†’            
   608â†’            let attributedString = NSAttributedString(string: customText, attributes: textAttributes)
   609â†’            let textSize = attributedString.size()
   610â†’            
   611â†’            let textRect = CGRect(
   612â†’                x: imageSize.width / 2 - textSize.width / 2,
   613â†’                y: imageSize.height - bottomBorderHeight / 2 - textSize.height / 2,
   614â†’                width: textSize.width,
   615â†’                height: textSize.height
   616â†’            )
   617â†’            
   618â†’            let line = CTLineCreateWithAttributedString(attributedString)
   619â†’            context.saveGState()
   620â†’            context.textMatrix = .identity
   621â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   622â†’            context.scaleBy(x: 1, y: -1)
   623â†’            CTLineDraw(line, context)
   624â†’            context.restoreGState()
   625â†’        }
   626â†’        
   627â†’        // ç»˜åˆ¶æ—¥æœŸ
   628â†’        if showDate {
   629â†’            let dateFormatter = DateFormatter()
   630â†’            dateFormatter.dateFormat = "yyyy.MM.dd"
   631â†’            let dateString = dateFormatter.string(from: Date())
   632â†’            
   633â†’            let fontSize = bottomBorderHeight * 0.25
   634â†’            let font = UIFont(name: "Marker Felt", size: fontSize) ?? UIFont.systemFont(ofSize: fontSize, weight: .light)
   635â†’            
   636â†’            let textAttributes: [NSAttributedString.Key: Any] = [
   637â†’                .font: font,
   638â†’                .foregroundColor: UIColor.black.withAlphaComponent(0.6)
   639â†’            ]
   640â†’            
   641â†’            let attributedString = NSAttributedString(string: dateString, attributes: textAttributes)
   642â†’            let textSize = attributedString.size()
   643â†’            
   644â†’            let textRect = CGRect(
   645â†’                x: imageSize.width - textSize.width - borderWidth,
   646â†’                y: imageSize.height - textSize.height - borderWidth * 0.5,
   647â†’                width: textSize.width,
   648â†’                height: textSize.height
   649â†’            )
   650â†’            
   651â†’            let line = CTLineCreateWithAttributedString(attributedString)
   652â†’            context.saveGState()
   653â†’            context.textMatrix = .identity
   654â†’            context.translateBy(x: textRect.minX, y: textRect.minY + textSize.height)
   655â†’            context.scaleBy(x: 1, y: -1)
   656â†’            CTLineDraw(line, context)
   657â†’            context.restoreGState()
   658â†’        }
   659â†’    }
   660â†’    
   661â†’    // ä¼˜åŒ–çš„Logoå›¾åƒè·å–ï¼ˆå†…å­˜ä¼˜åŒ–ï¼‰
   662â†’    private func getOptimizedLogoImage(_ logoName: String, maxSize: CGFloat) -> CGImage? {
   663â†’        guard let logoImage = UIImage(named: logoName)?.cgImage else { return nil }
   664â†’        
   665â†’        let originalWidth = CGFloat(logoImage.width)
   666â†’        let originalHeight = CGFloat(logoImage.height)
   667â†’        let maxDimension = max(originalWidth, originalHeight)
   668â†’        
   669â†’        // å¦‚æœLogoå·²ç»å¾ˆå°ï¼Œç›´æ¥è¿”å›
   670â†’        if maxDimension <= maxSize * 2 {
   671â†’            return logoImage
   672â†’        }
   673â†’        
   674â†’        // è®¡ç®—æ–°å°ºå¯¸
   675â†’        let scale = (maxSize * 2) / maxDimension
   676â†’        let newSize = CGSize(width: originalWidth * scale, height: originalHeight * scale)
   677â†’        
   678â†’        // ä½¿ç”¨Core Graphicsç¼©æ”¾
   679â†’        return createScaledImage(from: logoImage, size: newSize)
   680â†’    }
   681â†’}
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Glob**

Result:

```
/Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryMonitor.swift
/Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryPressureManager.swift
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Core/Utils/MemoryMonitor.swift`

Result:

```
1â†’import Foundation
     2â†’import os.log
     3â†’
     4â†’class MemoryMonitor {
     5â†’    static let shared = MemoryMonitor()
     6â†’    private let logger = Logger(subsystem: "MCCamera", category: "Memory")
     7â†’    
     8â†’    private init() {}
     9â†’    
    10â†’    // è·å–å½“å‰å†…å­˜ä½¿ç”¨æƒ…å†µ
    11â†’    func getCurrentMemoryUsage() -> (used: Int64, available: Int64) {
    12â†’        var info = mach_task_basic_info()
    13â†’        var count = mach_msg_type_number_t(MemoryLayout<mach_task_basic_info>.size)/4
    14â†’        
    15â†’        let kerr: kern_return_t = withUnsafeMutablePointer(to: &info) {
    16â†’            $0.withMemoryRebound(to: integer_t.self, capacity: 1) {
    17â†’                task_info(mach_task_self_,
    18â†’                         task_flavor_t(MACH_TASK_BASIC_INFO),
    19â†’                         $0,
    20â†’                         &count)
    21â†’            }
    22â†’        }
    23â†’        
    24â†’        if kerr == KERN_SUCCESS {
    25â†’            let usedMemory = Int64(info.resident_size)
    26â†’            let totalMemory = Int64(ProcessInfo.processInfo.physicalMemory)
    27â†’            return (used: usedMemory, available: totalMemory - usedMemory)
    28â†’        } else {
    29â†’            return (used: 0, available: 0)
    30â†’        }
    31â†’    }
    32â†’    
    33â†’    // æ ¼å¼åŒ–å†…å­˜å¤§å°æ˜¾ç¤º
    34â†’    func formatMemorySize(_ bytes: Int64) -> String {
    35â†’        let formatter = ByteCountFormatter()
    36â†’        formatter.allowedUnits = [.useMB, .useGB]
    37â†’        formatter.countStyle = .memory
    38â†’        return formatter.string(fromByteCount: bytes)
    39â†’    }
    40â†’    
    41â†’    // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
    42â†’    func logMemoryUsage(context: String) {
    43â†’        let memory = getCurrentMemoryUsage()
    44â†’        let usedMB = memory.used / 1024 / 1024
    45â†’        let availableMB = memory.available / 1024 / 1024
    46â†’        
    47â†’        let message = "\(context) - å·²ä½¿ç”¨: \(usedMB)MB, å¯ç”¨: \(availableMB)MB"
    48â†’        logger.info("\(message, privacy: .public)")
    49â†’        print("ğŸ§  \(message)")
    50â†’        
    51â†’        // å†…å­˜è­¦å‘Šé˜ˆå€¼æ£€æŸ¥
    52â†’        if usedMB > 300 {
    53â†’            logger.warning("å†…å­˜ä½¿ç”¨è¿‡é«˜: \(usedMB, privacy: .public)MB")
    54â†’            print("âš ï¸ å†…å­˜ä½¿ç”¨è¿‡é«˜: \(usedMB)MB")
    55â†’        }
    56â†’    }
    57â†’    
    58â†’    // æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å†…å­˜æ¸…ç†
    59â†’    func shouldTriggerMemoryCleanup() -> Bool {
    60â†’        let memory = getCurrentMemoryUsage()
    61â†’        let usedMB = memory.used / 1024 / 1024
    62â†’        return usedMB > 250 // è¶…è¿‡250MBè§¦å‘æ¸…ç†
    63â†’    }
    64â†’    
    65â†’    // å¼ºåˆ¶å†…å­˜æ¸…ç†
    66â†’    func forceMemoryCleanup() {
    67â†’        autoreleasepool {
    68â†’            // è§¦å‘è‡ªåŠ¨é‡Šæ”¾æ± æ¸…ç†
    69â†’        }
    70â†’        
    71â†’        // å»ºè®®ç³»ç»Ÿè¿›è¡Œå†…å­˜å›æ”¶
    72â†’        if #available(iOS 13.0, *) {
    73â†’            // iOS 13+ å¯ä»¥ä½¿ç”¨æ›´ç°ä»£çš„å†…å­˜ç®¡ç†
    74â†’        }
    75â†’        
    76â†’        logger.info("æ‰§è¡Œå†…å­˜æ¸…ç†")
    77â†’        print("ğŸ§¹ æ‰§è¡Œå†…å­˜æ¸…ç†")
    78â†’    }
    79â†’}
    80â†’
    81â†’// æ‰©å±•ä»¥æ”¯æŒå†…å­˜ç›‘æ§çš„è‡ªåŠ¨é‡Šæ”¾æ± 
    82â†’extension NSObject {
    83â†’    func withMemoryMonitoring<T>(context: String, _ closure: () throws -> T) rethrows -> T {
    84â†’        MemoryMonitor.shared.logMemoryUsage(context: "\(context) - å¼€å§‹")
    85â†’        
    86â†’        defer {
    87â†’            MemoryMonitor.shared.logMemoryUsage(context: "\(context) - ç»“æŸ")
    88â†’            
    89â†’            if MemoryMonitor.shared.shouldTriggerMemoryCleanup() {
    90â†’                MemoryMonitor.shared.forceMemoryCleanup()
    91â†’            }
    92â†’        }
    93â†’        
    94â†’        return try autoreleasepool {
    95â†’            return try closure()
    96â†’        }
    97â†’    }
    98â†’}
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Read** `./MCCamera/Core/Utils/MemoryPressureManager.swift`

Result:

```
1â†’import Foundation
     2â†’import UIKit
     3â†’import os.log
     4â†’
     5â†’class MemoryPressureManager: NSObject {
     6â†’    static let shared = MemoryPressureManager()
     7â†’    
     8â†’    private let logger = Logger(subsystem: "MCCamera", category: "MemoryPressure")
     9â†’    private var isHandlingMemoryWarning = false
    10â†’    
    11â†’    // å†…å­˜å‹åŠ›é˜ˆå€¼ (MB)
    12â†’    private let criticalMemoryThreshold: Int64 = 200 // 200MB
    13â†’    private let warningMemoryThreshold: Int64 = 150  // 150MB
    14â†’    
    15â†’    override init() {
    16â†’        super.init()
    17â†’        setupMemoryWarningNotifications()
    18â†’    }
    19â†’    
    20â†’    deinit {
    21â†’        NotificationCenter.default.removeObserver(self)
    22â†’    }
    23â†’    
    24â†’    private func setupMemoryWarningNotifications() {
    25â†’        NotificationCenter.default.addObserver(
    26â†’            self,
    27â†’            selector: #selector(handleMemoryWarning),
    28â†’            name: UIApplication.didReceiveMemoryWarningNotification,
    29â†’            object: nil
    30â†’        )
    31â†’    }
    32â†’    
    33â†’    @objc private func handleMemoryWarning() {
    34â†’        guard !isHandlingMemoryWarning else { return }
    35â†’        
    36â†’        isHandlingMemoryWarning = true
    37â†’        logger.critical("ğŸš¨ æ”¶åˆ°ç³»ç»Ÿå†…å­˜è­¦å‘Š")
    38â†’        
    39â†’        DispatchQueue.global(qos: .utility).async { [weak self] in
    40â†’            self?.performAggressiveMemoryCleanup()
    41â†’            
    42â†’            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
    43â†’                self?.isHandlingMemoryWarning = false
    44â†’            }
    45â†’        }
    46â†’    }
    47â†’    
    48â†’    // æ¿€è¿›çš„å†…å­˜æ¸…ç†
    49â†’    private func performAggressiveMemoryCleanup() {
    50â†’        logger.info("æ‰§è¡Œæ¿€è¿›å†…å­˜æ¸…ç†")
    51â†’        
    52â†’        // 1. å¼ºåˆ¶æ‰§è¡Œå¤šè½®åƒåœ¾å›æ”¶
    53â†’        for i in 0..<3 {
    54â†’            autoreleasepool {
    55â†’                // è§¦å‘è‡ªåŠ¨é‡Šæ”¾æ± æ¸…ç†
    56â†’                logger.debug("æ‰§è¡Œåƒåœ¾å›æ”¶è½®æ¬¡ \(i + 1)")
    57â†’            }
    58â†’        }
    59â†’        
    60â†’        // 2. æ¸…ç†URLCache
    61â†’        URLCache.shared.removeAllCachedResponses()
    62â†’        
    63â†’        // 3. å»ºè®®ç³»ç»Ÿå›æ”¶å†…å­˜
    64â†’        if #available(iOS 13.0, *) {
    65â†’            // ç°ä»£å†…å­˜ç®¡ç†
    66â†’        } else {
    67â†’            // å…¼å®¹è€ç‰ˆæœ¬
    68â†’        }
    69â†’        
    70â†’        // 4. è®°å½•æ¸…ç†åçš„å†…å­˜çŠ¶æ€
    71â†’        let afterMemory = MemoryMonitor.shared.getCurrentMemoryUsage()
    72â†’        logger.info("å†…å­˜æ¸…ç†å®Œæˆï¼Œå½“å‰ä½¿ç”¨: \(afterMemory.used / 1024 / 1024)MB")
    73â†’    }
    74â†’    
    75â†’    // æ£€æŸ¥å†…å­˜å‹åŠ›çº§åˆ«
    76â†’    func checkMemoryPressure() -> MemoryPressureLevel {
    77â†’        let memory = MemoryMonitor.shared.getCurrentMemoryUsage()
    78â†’        let usedMB = memory.used / 1024 / 1024
    79â†’        
    80â†’        if usedMB >= criticalMemoryThreshold {
    81â†’            logger.warning("å†…å­˜å‹åŠ›ï¼šå±é™© (\(usedMB)MB)")
    82â†’            return .critical
    83â†’        } else if usedMB >= warningMemoryThreshold {
    84â†’            logger.info("å†…å­˜å‹åŠ›ï¼šè­¦å‘Š (\(usedMB)MB)")
    85â†’            return .warning
    86â†’        } else {
    87â†’            return .normal
    88â†’        }
    89â†’    }
    90â†’    
    91â†’    // æ ¹æ®å†…å­˜å‹åŠ›è°ƒæ•´å¤„ç†ç­–ç•¥
    92â†’    func getOptimalProcessingStrategy() -> ImageProcessingStrategy {
    93â†’        let pressureLevel = checkMemoryPressure()
    94â†’        
    95â†’        switch pressureLevel {
    96â†’        case .critical:
    97â†’            logger.warning("é‡‡ç”¨æç«¯å†…å­˜ä¼˜åŒ–ç­–ç•¥")
    98â†’            return .ultraLowMemory
    99â†’        case .warning:
   100â†’            logger.info("é‡‡ç”¨ä½å†…å­˜ä¼˜åŒ–ç­–ç•¥")
   101â†’            return .lowMemory
   102â†’        case .normal:
   103â†’            return .standard
   104â†’        }
   105â†’    }
   106â†’    
   107â†’    // é¢„é˜²æ€§å†…å­˜æ¸…ç†
   108â†’    func performPreventiveCleanup() {
   109â†’        let pressureLevel = checkMemoryPressure()
   110â†’        
   111â†’        if pressureLevel != .normal {
   112â†’            logger.info("æ‰§è¡Œé¢„é˜²æ€§å†…å­˜æ¸…ç†")
   113â†’            autoreleasepool {
   114â†’                // è½»é‡çº§æ¸…ç†
   115â†’            }
   116â†’        }
   117â†’    }
   118â†’}
   119â†’
   120â†’// å†…å­˜å‹åŠ›çº§åˆ«
   121â†’enum MemoryPressureLevel {
   122â†’    case normal
   123â†’    case warning
   124â†’    case critical
   125â†’}
   126â†’
   127â†’// å›¾åƒå¤„ç†ç­–ç•¥
   128â†’enum ImageProcessingStrategy {
   129â†’    case standard      // æ ‡å‡†å¤„ç†ï¼šæ­£å¸¸è´¨é‡
   130â†’    case lowMemory     // ä½å†…å­˜æ¨¡å¼ï¼šé€‚åº¦å‹ç¼©
   131â†’    case ultraLowMemory // æä½å†…å­˜æ¨¡å¼ï¼šæ¿€è¿›å‹ç¼©
   132â†’    
   133â†’    var maxPixels: Int {
   134â†’        switch self {
   135â†’        case .standard:
   136â†’            return 25_000_000  // 25MP
   137â†’        case .lowMemory:
   138â†’            return 12_000_000  // 12MP
   139â†’        case .ultraLowMemory:
   140â†’            return 6_000_000   // 6MP
   141â†’        }
   142â†’    }
   143â†’    
   144â†’    var compressionQuality: CGFloat {
   145â†’        switch self {
   146â†’        case .standard:
   147â†’            return 0.9
   148â†’        case .lowMemory:
   149â†’            return 0.8
   150â†’        case .ultraLowMemory:
   151â†’            return 0.7
   152â†’        }
   153â†’    }
   154â†’}
```

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] ğŸŒ¡ï¸ Analyze PhotoProcessor.swift for memory issues
- [X] ğŸŒ¡ï¸ Check PhotoDecorationService.swift for memory leaks
- [âš¡] ğŸŒ¡ï¸ Review camera capture flow for proper memory management
- [ ] ğŸŒ¡ï¸ Implement image memory optimization techniques
- [ ] ğŸŒ¡ï¸ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

Based on my analysis of the codebase, I've identified several critical memory issues that are likely causing the app to crash. Here are the key problems and my recommendations:

## Critical Memory Issues Found:

### 1. **Excessive Memory Usage in Photo Processing**
- The app is attempting to process 48MP images (8064Ã—6048) directly in memory
- Each 48MP image requires ~300MB+ of RAM when decompressed
- Multiple image copies are created during processing without proper cleanup

### 2. **Missing Memory Pressure Handling**
- While you have monitoring code, the critical thresholds are too high (200MB threshold on iOS 14 device is too late)
- The app doesn't properly abort operations when memory is critically low

### 3. **CGImage Memory Leaks**
- Creating multiple CGImage instances without immediate release
- Core Graphics contexts not being properly managed

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] ğŸŒ¡ï¸ Analyze PhotoProcessor.swift for memory issues
- [X] ğŸŒ¡ï¸ Check PhotoDecorationService.swift for memory leaks
- [X] ğŸŒ¡ï¸ Review camera capture flow for proper memory management
- [âš¡] ğŸŒ¡ï¸ Implement image memory optimization techniques
- [ ] ğŸŒ¡ï¸ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

## Immediate Memory Optimizations:

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Core/Utils/MemoryPressureManager.swift`

Result:

```
Applied 3 edits to /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryPressureManager.swift:
1. Replaced "    // å†…å­˜å‹åŠ›é˜ˆå€¼ (MB)
    private let criticalMemoryT..." with "    // å†…å­˜å‹åŠ›é˜ˆå€¼ (MB) - é’ˆå¯¹iOS 14è®¾å¤‡ä¼˜åŒ–
    private let ..."
2. Replaced "    var maxPixels: Int {
        switch self {
   ..." with "    var maxPixels: Int {
        switch self {
   ..."
3. Replaced "    var compressionQuality: CGFloat {
        swit..." with "    var compressionQuality: CGFloat {
        swit..."
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Core/Utils/MemoryMonitor.swift`

Result:

```
Applied 2 edits to /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Utils/MemoryMonitor.swift:
1. Replaced "        // å†…å­˜è­¦å‘Šé˜ˆå€¼æ£€æŸ¥
        if usedMB > 300 {
    ..." with "        // å†…å­˜è­¦å‘Šé˜ˆå€¼æ£€æŸ¥ - é’ˆå¯¹iOS 14è®¾å¤‡ä¼˜åŒ–
        if used..."
2. Replaced "    // æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å†…å­˜æ¸…ç†
    func shouldTriggerMemoryCl..." with "    // æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘å†…å­˜æ¸…ç† - æ›´ç§¯æçš„ç­–ç•¥
    func shouldTrigge..."
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Core/Photo/PhotoProcessor.swift`

Error:

```
<tool_use_error>String to replace not found in file.
String:             // åœ¨ä½å…‰ç¯å¢ƒä¸‹ï¼Œç³»ç»Ÿå¯èƒ½ä¼šè‡ªåŠ¨å›é€€åˆ° 12MP ä»¥è·å¾—æ›´å¥½çš„ç”»è´¨ï¼Œè¿™æ˜¯ç¡¬ä»¶å’Œç³»ç»Ÿå±‚é¢çš„ä¼˜åŒ–ã€‚
æ€§èƒ½: æ‹æ‘„å’Œå¤„ç† 48MP ç…§ç‰‡è€—æ—¶æ›´é•¿ï¼Œéœ€è¦åšå¥½ UI åé¦ˆï¼ˆå¦‚åŠ è½½æŒ‡ç¤ºå™¨ï¼‰ã€‚
ProRAW vs HEIF Max: ä¸¤è€…é€šå¸¸æ˜¯äº’æ–¥çš„ã€‚HEIF Max æ˜¯ç»è¿‡è‹¹æœå›¾åƒç®¡çº¿å¤„ç†çš„é«˜åˆ†è¾¨ç‡ç…§ç‰‡ï¼Œè€Œ ProRAW æ˜¯æœªç»å¤„ç†çš„åŸå§‹ä¼ æ„Ÿå™¨æ•°æ®ã€‚</tool_use_error>
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     9â†’    init(locationManager: LocationManager) {
    10â†’        self.locationManager = locationManager
    11â†’    }
    12â†’    
    13â†’    func savePhotoToLibrary(_ imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio? = nil, frameSettings: FrameSettings? = nil) {
    14â†’        // ç«‹å³æ£€æŸ¥å†…å­˜çŠ¶æ€
    15â†’        MemoryMonitor.shared.logMemoryUsage(context: "ä¿å­˜ç…§ç‰‡å¼€å§‹")
    16â†’        
    17â†’        // å¦‚æœå†…å­˜å±é™©ï¼Œç«‹å³ä½¿ç”¨æœ€ç®€ä¿å­˜ç­–ç•¥
    18â†’        if MemoryMonitor.shared.shouldAbortOperation() {
    19â†’            print("ğŸš¨ å†…å­˜ä¸è¶³ï¼Œä½¿ç”¨ç´§æ€¥ä¿å­˜æ¨¡å¼")
    20â†’            saveEmergencyMode(imageData)
    21â†’            return
    22â†’        }
    23â†’        
    24â†’        PHPhotoLibrary.requestAuthorization { [weak self] status in
    25â†’            guard status == .authorized else {
    26â†’                print("âŒ ç›¸å†Œæƒé™æœªæˆæƒ")
    27â†’                return
    28â†’            }
    29â†’            
    30â†’            // æ£€æŸ¥æ˜¯å¦ä¸ºè¶…å¤§å›¾åƒï¼Œå¦‚æœæ˜¯åˆ™ä½¿ç”¨æœ€ç®€ä¿å­˜ç­–ç•¥
    31â†’            if let self = self, self.isUltraLargeImage(imageData) {
    32â†’                print("ğŸš¨ æ£€æµ‹åˆ°è¶…å¤§å›¾åƒï¼Œä½¿ç”¨ç´§æ€¥ä¿å­˜æ¨¡å¼")
    33â†’                self.saveUltraLargeImageDirectly(imageData)
    34â†’                return
    35â†’            }
    36â†’            
    37â†’            // ä½¿ç”¨autoreleasepoolå‡å°‘å†…å­˜å ç”¨
    38â†’            autoreleasepool {
    39â†’                // å…ˆæ£€æŸ¥åŸå§‹æ•°æ®æ˜¯å¦åŒ…å«å®Œæ•´å…ƒæ•°æ®
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    58â†’            }
    59â†’        }
    60â†’    }
    61â†’    
    62â†’    // ç´§æ€¥æ¨¡å¼ä¿å­˜ - å†…å­˜ä¸è¶³æ—¶ä½¿ç”¨
    63â†’    private func saveEmergencyMode(_ imageData: Data) {
    64â†’        PHPhotoLibrary.shared().performChanges({
    65â†’            let creationRequest = PHAssetCreationRequest.forAsset()
    66â†’            creationRequest.addResource(with: .photo, data: imageData, options: nil)
    67â†’        }) { success, error in
    68â†’            if success {
    69â†’                print("âœ… ç´§æ€¥æ¨¡å¼ä¿å­˜æˆåŠŸ")
    70â†’            } else {
    71â†’                print("âŒ ç´§æ€¥æ¨¡å¼ä¿å­˜å¤±è´¥: \(error?.localizedDescription ?? "æœªçŸ¥é”™è¯¯")")
    72â†’            }
    73â†’        }
    74â†’    }
    75â†’    
    76â†’    // æ£€æŸ¥æ˜¯å¦ä¸ºè¶…å¤§å›¾åƒ - é™ä½é˜ˆå€¼
    77â†’    private func isUltraLargeImage(_ imageData: Data) -> Bool {
    78â†’        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
    79â†’              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [String: Any],
    80â†’              let width = properties[kCGImagePropertyPixelWidth as String] as? Int,
    81â†’              let height = properties[kCGImagePropertyPixelHeight as String] as? Int else {
    82â†’            return false
    83â†’        }
    84â†’        
    85â†’        let megapixels = (width * height) / 1_000_000
    86â†’        return megapixels >= 15 // 15MPä»¥ä¸Šè®¤ä¸ºæ˜¯è¶…å¤§å›¾åƒ (é™ä½é˜ˆå€¼)
    87â†’    }
    88â†’    
    89â†’    // è¶…å¤§å›¾åƒç›´æ¥ä¿å­˜ï¼ˆé›¶å¤„ç†ï¼‰
    90â†’    private func saveUltraLargeImageDirectly(_ imageData: Data) {
    91â†’        PHPhotoLibrary.shared().performChanges({
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   159â†’            print("  - é«˜åº¦: \(originalHeight)")
   160â†’            print("  - æ€»åƒç´ : \(originalMegapixels)MP")
   161â†’            print("  - æ˜¯å¦ä¸º48MP: \(originalMegapixels >= 40)")
   162â†’            
   163â†’            // å…³é”®ä¼˜åŒ–ï¼šç«‹å³æ£€æŸ¥å†…å­˜çŠ¶æ€
   164â†’            if MemoryMonitor.shared.shouldAbortOperation() {
   165â†’                print("ğŸš¨ å†…å­˜ä¸è¶³ï¼Œç»ˆæ­¢å¤æ‚å¤„ç†")
   166â†’                resultData = imageData // ç›´æ¥è¿”å›åŸå§‹æ•°æ®
   167â†’                return
   168â†’            }
   169â†’            
   170â†’            // ğŸš¨ å¤§å›¾åƒç‰¹æ®Šå¤„ç†ï¼šé¿å…å†…å­˜çˆ†ç‚¸ - é™ä½é˜ˆå€¼
   171â†’            if originalMegapixels >= 20 {
   172â†’                print("ğŸš¨ æ£€æµ‹åˆ°å¤§å›¾åƒ(\(originalMegapixels)MP)ï¼å¯ç”¨æç®€å¤„ç†æ¨¡å¼")
   173â†’                resultData = handleUltraHighResolutionImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   174â†’                return
   175â†’            } else if originalMegapixels >= 8 {
   176â†’                print("âš¡ æ£€æµ‹åˆ°ä¸­å°ºå¯¸å›¾åƒï¼Œå¯ç”¨ä¼˜åŒ–å¤„ç†")
   177â†’                resultData = handleLargeImage(source: source, imageData: imageData, format: format, aspectRatio: aspectRatio)
   178â†’                return
   179â†’            }
   180â†’            
   181â†’            print("âœ… æ ‡å‡†å›¾åƒï¼Œä½¿ç”¨å¸¸è§„å¤„ç†")
   182â†’            
   183â†’            // å¸¸è§„å›¾åƒå¤„ç†ï¼ˆå°äº20MPï¼‰
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   353â†’        // æ£€æŸ¥å½“å‰å†…å­˜å‹åŠ›
   354â†’        let memoryUsage = MemoryMonitor.shared.getCurrentMemoryUsage()
   355â†’        let usedMB = memoryUsage.used / 1024 / 1024
   356â†’        
   357â†’        // å¦‚æœå†…å­˜å‹åŠ›æå¤§ï¼Œç›´æ¥è¿”å›åŸå§‹æ•°æ® - æ›´ç§¯æçš„ç­–ç•¥
   358â†’        if usedMB > 100 {
   359â†’            print("ğŸš¨ å†…å­˜å‹åŠ›è¿‡å¤§(\(usedMB)MB)ï¼Œç›´æ¥ä¿å­˜åŸå§‹æ•°æ®")
   360â†’            return imageData
   361â†’        }
   362â†’        
   363â†’        // å¦‚æœæ²¡æœ‰è£å‰ªéœ€æ±‚ä¸”æ ¼å¼åŒ¹é…ï¼Œç›´æ¥è¿”å›åŸå§‹æ•°æ®
   364â†’        if aspectRatio == nil || aspectRatio == .ratio4_3 {
   365â†’            print("ğŸš€ æ— éœ€å¤„ç†ï¼Œç›´æ¥ä¿å­˜åŸå§‹48MPæ•°æ®")
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   408â†’        print("âœ… 48MPæœ€å°åŒ–å¤„ç†å®Œæˆ")
   409â†’        return mutableData as Data
   410â†’    }
   411â†’    
   412â†’    // å¤§å›¾åƒä¼˜åŒ–å¤„ç†ï¼ˆ8-20MPï¼‰
   413â†’    private func handleLargeImage(source: CGImageSource, imageData: Data, format: PhotoFormat, aspectRatio: AspectRatio?) -> Data {
   414â†’        print("âš¡ å¤§å›¾åƒä¼˜åŒ–å¤„ç†")
   415â†’        
   416â†’        // ä½¿ç”¨é™é‡‡æ ·æŠ€æœ¯ï¼Œé¿å…å°†å®Œæ•´å›¾åƒåŠ è½½åˆ°å†…å­˜
   417â†’        let maxPixelSize = 2000 // æ›´ä¿å®ˆçš„é™åˆ¶ - 2000px
   418â†’        
   419â†’        let options: [CFString: Any] = [
   420â†’            kCGImageSourceCreateThumbnailFromImageAlways: true,
   421â†’            kCGImageSourceCreateThumbnailWithTransform: true,
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Features/Frame/Services/PhotoDecorationService.swift`

Error:

```
<tool_use_error>String to replace not found in file.
String:         // åˆ›å»ºå†…å­˜ä¼˜åŒ–çš„UIImage - æç«¯ä¼˜åŒ–ç‰ˆæœ¬
    private func createOptimizedUIImage(from imageData: Data, pixelCount: Int) -> UIImage? {
        // æ›´æ¿€è¿›çš„å†…å­˜æ§åˆ¶ç­–ç•¥
        if pixelCount > 48_000_000 { // 48MP - æç«¯å‹ç¼©
            print("ğŸš¨ æ£€æµ‹åˆ°48MPå›¾åƒï¼Œå¯ç”¨æç«¯å†…å­˜ä¼˜åŒ–")
            return createUltraDownsampledImage(from: imageData, maxPixels: 8_000_000) // é™è‡³8MP
        } else if pixelCount > 20_000_000 { // 20MP+ - æ¿€è¿›å‹ç¼©
            print("âš¡ æ£€æµ‹åˆ°å¤§å›¾åƒï¼Œå¯ç”¨æ¿€è¿›å†…å­˜ä¼˜åŒ–")
            return createDownsampledImage(from: imageData, maxPixels: 12_000_000) // é™è‡³12MP
        } else if pixelCount > 10_000_000 { // 10MP+ - é€‚åº¦å‹ç¼©
            return createDownsampledImage(from: imageData, maxPixels: 8_000_000) // é™è‡³8MP
        } else {
            // å°å›¾åƒç›´æ¥åˆ›å»º
            return UIImage(data: imageData)
        }
    }</tool_use_error>
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Features/Frame/Services/PhotoDecorationService.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   133â†’            return createOptimizedUIImage(from: imageData, pixelCount: pixelCount)
   134â†’        }
   135â†’    }
   136â†’    
   137â†’    // åˆ›å»ºå†…å­˜ä¼˜åŒ–çš„UIImage - æç«¯ä¼˜åŒ–ç‰ˆæœ¬
   138â†’    private func createOptimizedUIImage(from imageData: Data, pixelCount: Int) -> UIImage? {
   139â†’        // ç«‹å³æ£€æŸ¥å†…å­˜çŠ¶æ€
   140â†’        if MemoryMonitor.shared.shouldAbortOperation() {
   141â†’            print("ğŸš¨ å†…å­˜å±é™©ï¼Œä½¿ç”¨æœ€å°é™é‡‡æ ·")
   142â†’            return createUltraDownsampledImage(from: imageData, maxPixels: 1_000_000) // 1MP
   143â†’        }
   144â†’        
   145â†’        // æ›´æ¿€è¿›çš„å†…å­˜æ§åˆ¶ç­–ç•¥ - å¤§å¹…é™ä½é˜ˆå€¼
   146â†’        if pixelCount > 20_000_000 { // 20MP+ - æç«¯å‹ç¼©
   147â†’            print("ğŸš¨ æ£€æµ‹åˆ°è¶…å¤§å›¾åƒï¼Œå¯ç”¨æç«¯å†…å­˜ä¼˜åŒ–")
   148â†’            return createUltraDownsampledImage(from: imageData, maxPixels: 3_000_000) // é™è‡³3MP
   149â†’        } else if pixelCount > 8_000_000 { // 8MP+ - æ¿€è¿›å‹ç¼©
   150â†’            print("âš¡ æ£€æµ‹åˆ°å¤§å›¾åƒï¼Œå¯ç”¨æ¿€è¿›å†…å­˜ä¼˜åŒ–")
   151â†’            return createDownsampledImage(from: imageData, maxPixels: 4_000_000) // é™è‡³4MP
   152â†’        } else if pixelCount > 4_000_000 { // 4MP+ - é€‚åº¦å‹ç¼©
   153â†’            return createDownsampledImage(from: imageData, maxPixels: 3_000_000) // é™è‡³3MP
   154â†’        } else {
   155â†’            // å°å›¾åƒç›´æ¥åˆ›å»º
   156â†’            return UIImage(data: imageData)
   157â†’        }
   158â†’    }
   159â†’    
   160â†’    // æç«¯é™é‡‡æ ·å›¾åƒï¼ˆç”¨äº48MPç­‰è¶…å¤§å›¾åƒï¼‰
   161â†’    private func createUltraDownsampledImage(from imageData: Data, maxPixels: Int) -> UIImage? {
   162â†’        guard let source = CGImageSourceCreateWithData(imageData as CFData, nil) else { return nil }
```

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **MultiEdit** `./MCCamera/Features/Frame/Services/OptimizedPhotoDecorationRenderer.swift`

Result:

```
Applied 2 edits to /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Features/Frame/Services/OptimizedPhotoDecorationRenderer.swift:
1. Replaced "    // å†…å­˜ä¼˜åŒ–é…ç½® - æ›´æ¿€è¿›çš„è®¾ç½®
    private let maxRenderSi..." with "    // å†…å­˜ä¼˜åŒ–é…ç½® - æç«¯ä¿å®ˆçš„è®¾ç½®
    private let maxRenderS..."
2. Replaced "            // è®¡ç®—ç¼©æ”¾å› å­ - æ›´æ¿€è¿›çš„ç¼©å°ç­–ç•¥
            let t..." with "            // è®¡ç®—ç¼©æ”¾å› å­ - æç«¯æ¿€è¿›çš„ç¼©å°ç­–ç•¥
            let ..."
```

_**Agent (claude-sonnet-4-20250514)**_

Now let me add an important enhancement to handle memory warnings in real-time:

_**Agent (claude-sonnet-4-20250514)**_

Tool use: **Edit**

Result:

```
The file /Users/macongcong/Desktop/MC/MCCamera/MCCamera/Core/Photo/PhotoProcessor.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   325â†’            
   326â†’            // å…ˆè®¾ç½®å±æ€§ï¼Œå†æ·»åŠ å›¾åƒ
   327â†’            CGImageDestinationSetProperties(destination, options as CFDictionary)
   328â†’            
   329â†’            // åœ¨æ·»åŠ å›¾åƒä¹‹å‰å†æ¬¡æ£€æŸ¥å†…å­˜
   330â†’            if MemoryMonitor.shared.shouldAbortOperation() {
   331â†’                print("ğŸš¨ å¤„ç†è¿‡ç¨‹ä¸­å†…å­˜ä¸è¶³ï¼Œè¿”å›åŸå§‹æ•°æ®")
   332â†’                resultData = imageData
   333â†’                return
   334â†’            }
   335â†’            
   336â†’            // æ·»åŠ å›¾åƒå’Œå…ƒæ•°æ®
   337â†’            CGImageDestinationAddImage(destination, processedCGImage, metadata as CFDictionary)
   338â†’            
   339â†’            // å®Œæˆå†™å…¥
   340â†’            guard CGImageDestinationFinalize(destination) else {
   341â†’                print("âŒ æ— æ³•å®Œæˆå›¾åƒå†™å…¥")
   342â†’                resultData = imageData
   343â†’                return
   344â†’            }
   345â†’            
   346â†’            // éªŒè¯ä¿å­˜çš„å…ƒæ•°æ®
   347â†’            verifyMetadata(mutableData)
   348â†’
```

_**Agent (claude-sonnet-4-20250514)**_

**Agent task list:**
- [X] ğŸŒ¡ï¸ Analyze PhotoProcessor.swift for memory issues
- [X] ğŸŒ¡ï¸ Check PhotoDecorationService.swift for memory leaks
- [X] ğŸŒ¡ï¸ Review camera capture flow for proper memory management
- [X] ğŸŒ¡ï¸ Implement image memory optimization techniques
- [ ] ğŸŒ¡ï¸ Test memory usage after optimizations


_**Agent (claude-sonnet-4-20250514)**_

## å†…å­˜ä¼˜åŒ–æ€»ç»“

æˆ‘å·²ç»å®Œæˆäº†å¯¹ä½ çš„ç›¸æœºåº”ç”¨çš„å…¨é¢å†…å­˜ä¼˜åŒ–ï¼Œä¸»è¦é’ˆå¯¹ä»¥ä¸‹å…³é”®é—®é¢˜ï¼š

### ğŸ”§ **æ ¸å¿ƒä¼˜åŒ–æªæ–½:**

1. **é™ä½å†…å­˜é˜ˆå€¼** - ä»300MBè°ƒæ•´ä¸º100MBå±é™©çº¿ï¼Œ80MBè§¦å‘æ¸…ç†
2. **æ›´æ¿€è¿›çš„å›¾åƒå‹ç¼©** - å¤§å¹…é™ä½å¤„ç†åƒç´ ä¸Šé™å’Œå‹ç¼©è´¨é‡
3. **ç´§æ€¥ä¿å­˜æ¨¡å¼** - å†…å­˜ä¸è¶³æ—¶ç›´æ¥ä¿å­˜åŸå›¾ï¼Œè·³è¿‡æ‰€æœ‰å¤„ç†
4. **å®æ—¶å†…å­˜æ£€æŸ¥** - åœ¨å¤„ç†è¿‡ç¨‹ä¸­å¤šæ¬¡æ£€æŸ¥å†…å­˜çŠ¶æ€
5. **é™ä½è§¦å‘é˜ˆå€¼** - 15MPä»¥ä¸Šå°±è®¤ä¸ºæ˜¯è¶…å¤§å›¾åƒï¼ˆåŸ40MPï¼‰

### ğŸ“Š **å…·ä½“æ•°å€¼ä¼˜åŒ–:**

- **åƒç´ é™åˆ¶**: æ ‡å‡†æ¨¡å¼ä»25MPâ†’8MPï¼Œä½å†…å­˜4MPï¼Œæç«¯2MP
- **å†…å­˜é˜ˆå€¼**: å±é™©çº¿ä»200MBâ†’120MBï¼Œè­¦å‘Šä»150MBâ†’80MB  
- **æ¸²æŸ“å°ºå¯¸**: ä»1536pxâ†’1200pxï¼Œç¼©æ”¾é™åˆ¶ä»50%â†’30%
- **å‹ç¼©è´¨é‡**: æ ‡å‡†0.9â†’0.75ï¼Œä½å†…å­˜0.65ï¼Œæç«¯0.5

### âš¡ **å…³é”®æ”¹è¿›:**
- æ·»åŠ äº†ç´§æ€¥æ¨¡å¼ä¿å­˜ï¼Œå†…å­˜å±é™©æ—¶é›¶å¤„ç†ç›´æ¥ä¿å­˜
- å¤„ç†è¿‡ç¨‹ä¸­å¤šç‚¹å†…å­˜æ£€æŸ¥ï¼Œå¯éšæ—¶ä¸­æ­¢é¿å…å´©æºƒ
- å¯¹iOS 14è®¾å¤‡çš„å†…å­˜é™åˆ¶è¿›è¡Œäº†ä¸“é—¨ä¼˜åŒ–

ç°åœ¨è¯·æµ‹è¯•åº”ç”¨ï¼Œç‰¹åˆ«æ˜¯æ‹æ‘„å¤§å°ºå¯¸ç…§ç‰‡æ—¶çš„å†…å­˜è¡¨ç°ã€‚å¦‚æœä»æœ‰é—®é¢˜ï¼Œæˆ‘å¯ä»¥è¿›ä¸€æ­¥é™ä½é˜ˆå€¼æˆ–æ·»åŠ æ›´å¤šä¿æŠ¤æªæ–½ã€‚

