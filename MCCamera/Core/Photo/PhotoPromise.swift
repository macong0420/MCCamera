import Foundation
import UIKit
import AVFoundation

// MARK: - ÁÖßÁâáÂ§ÑÁêÜPromise - ÂìçÂ∫îÂºèÁºñÁ®ãÊ®°Âûã
class PhotoPromise {
    let taskId: UUID
    
    // MARK: - Â§ÑÁêÜÁä∂ÊÄÅ
    enum State {
        case pending
        case previewReady
        case preprocessing  
        case rendering
        case completed
        case failed(Error)
        case cancelled
    }
    
    private var _state: State = .pending
    private let stateQueue = DispatchQueue(label: "com.mccamera.promise.state", attributes: .concurrent)
    
    var state: State {
        return stateQueue.sync { _state }
    }
    
    // MARK: - ÂõûË∞ÉÈó≠ÂåÖ
    var onPreviewReady: ((Data) -> Void)?
    var onPreprocessComplete: (() -> Void)?
    var onRenderingStart: (() -> Void)?
    var onProgressUpdate: ((Float) -> Void)?
    var onCompleted: ((Data) -> Void)?
    var onError: ((Error) -> Void)?
    var onMemoryDelay: (() -> Void)?
    
    // MARK: - Â§ÑÁêÜÊï∞ÊçÆ
    private var previewData: Data?
    private var finalData: Data?
    private var error: Error?
    
    // MARK: - Êó∂Èó¥ÁªüËÆ°
    private let startTime: CFAbsoluteTime
    private var previewTime: CFAbsoluteTime?
    private var preprocessTime: CFAbsoluteTime?
    private var completeTime: CFAbsoluteTime?
    
    init(taskId: UUID) {
        self.taskId = taskId
        self.startTime = CFAbsoluteTimeGetCurrent()
        
        print("üéØ PhotoPromiseÂàõÂª∫: \(taskId.uuidString.prefix(8))")
    }
    
    // MARK: - Áä∂ÊÄÅÈÄöÁü•ÊñπÊ≥ï
    
    func notifyPreviewReady(_ data: Data) {
        stateQueue.async(flags: .barrier) { [weak self] in
            guard let self = self else { return }
            self._state = .previewReady
            self.previewData = data
            self.previewTime = CFAbsoluteTimeGetCurrent()
            
            let duration = Int((self.previewTime! - self.startTime) * 1000)
            print("üëÅÔ∏è PreviewÂ∞±Áª™: \(self.taskId.uuidString.prefix(8)) - \(duration)ms")
            
            DispatchQueue.main.async {
                self.onPreviewReady?(data)
                self.onProgressUpdate?(0.3) // 30%ËøõÂ∫¶
            }
        }
    }
    
    func notifyPreprocessComplete() {
        stateQueue.async(flags: .barrier) { [weak self] in
            guard let self = self else { return }
            self._state = .preprocessing
            self.preprocessTime = CFAbsoluteTimeGetCurrent()
            
            if let startTime = self.previewTime {
                let duration = Int((self.preprocessTime! - startTime) * 1000)
                print("‚öôÔ∏è È¢ÑÂ§ÑÁêÜÂÆåÊàê: \(self.taskId.uuidString.prefix(8)) - \(duration)ms")
            }
            
            DispatchQueue.main.async {
                self.onPreprocessComplete?()
                self.onProgressUpdate?(0.6) // 60%ËøõÂ∫¶
            }
        }
    }
    
    func notifyRenderingStart() {
        stateQueue.async(flags: .barrier) { [weak self] in
            guard let self = self else { return }
            self._state = .rendering
            
            print("üé® ÂºÄÂßãÊ∏≤Êüì: \(self.taskId.uuidString.prefix(8))")
            
            DispatchQueue.main.async {
                self.onRenderingStart?()
                self.onProgressUpdate?(0.7) // 70%ËøõÂ∫¶
            }
        }
    }
    
    func notifyComplete(_ data: Data) {
        stateQueue.async(flags: .barrier) { [weak self] in
            guard let self = self else { return }
            self._state = .completed
            self.finalData = data
            self.completeTime = CFAbsoluteTimeGetCurrent()
            
            let totalDuration = Int((self.completeTime! - self.startTime) * 1000)
            print("‚úÖ Â§ÑÁêÜÂÆåÊàê: \(self.taskId.uuidString.prefix(8)) - ÊÄªËÄóÊó∂: \(totalDuration)ms")
            
            // ÊâìÂç∞ËØ¶ÁªÜÊó∂Èó¥ÁªüËÆ°
            self.printTimeStatistics()
            
            DispatchQueue.main.async {
                self.onCompleted?(data)
                self.onProgressUpdate?(1.0) // 100%ÂÆåÊàê
            }
        }
    }
    
    func notifyError(_ error: Error) {
        stateQueue.async(flags: .barrier) { [weak self] in
            guard let self = self else { return }
            self._state = .failed(error)
            self.error = error
            
            print("‚ùå Â§ÑÁêÜÂ§±Ë¥•: \(self.taskId.uuidString.prefix(8)) - \(error)")
            
            DispatchQueue.main.async {
                self.onError?(error)
            }
        }
    }
    
    func notifyMemoryDelay() {
        print("‚è≥ ÂÜÖÂ≠òÂª∂Ëøü: \(taskId.uuidString.prefix(8))")
        
        DispatchQueue.main.async { [weak self] in
            self?.onMemoryDelay?()
        }
    }
    
    // MARK: - ÈìæÂºèË∞ÉÁî®ÊñπÊ≥ï (Fluent API)
    
    @discardableResult
    func onPreview(_ callback: @escaping (Data) -> Void) -> PhotoPromise {
        self.onPreviewReady = callback
        
        // Â¶ÇÊûúÈ¢ÑËßàÂ∑≤ÁªèÂ∞±Áª™ÔºåÁ´ãÂç≥ÂõûË∞É
        if case .previewReady = state, let data = previewData {
            DispatchQueue.main.async {
                callback(data)
            }
        }
        
        return self
    }
    
    @discardableResult
    func onPreprocess(_ callback: @escaping () -> Void) -> PhotoPromise {
        self.onPreprocessComplete = callback
        return self
    }
    
    @discardableResult
    func onProgress(_ callback: @escaping (Float) -> Void) -> PhotoPromise {
        self.onProgressUpdate = callback
        return self
    }
    
    @discardableResult
    func onSuccess(_ callback: @escaping (Data) -> Void) -> PhotoPromise {
        self.onCompleted = callback
        
        // Â¶ÇÊûúÂ∑≤ÁªèÂÆåÊàêÔºåÁ´ãÂç≥ÂõûË∞É
        if case .completed = state, let data = finalData {
            DispatchQueue.main.async {
                callback(data)
            }
        }
        
        return self
    }
    
    @discardableResult
    func onFailure(_ callback: @escaping (Error) -> Void) -> PhotoPromise {
        self.onError = callback
        
        // Â¶ÇÊûúÂ∑≤ÁªèÂ§±Ë¥•ÔºåÁ´ãÂç≥ÂõûË∞É
        if case .failed(let error) = state {
            DispatchQueue.main.async {
                callback(error)
            }
        }
        
        return self
    }
    
    @discardableResult
    func onMemoryPressure(_ callback: @escaping () -> Void) -> PhotoPromise {
        self.onMemoryDelay = callback
        return self
    }
    
    // MARK: - ËæÖÂä©ÊñπÊ≥ï
    
    func cancel() {
        stateQueue.async(flags: .barrier) { [weak self] in
            guard let self = self else { return }
            
            if case .completed = self._state { return } // Â∑≤ÂÆåÊàêÁöÑ‰∏çËÉΩÂèñÊ∂à
            if case .failed = self._state { return } // Â∑≤Â§±Ë¥•ÁöÑ‰∏çËÉΩÂèñÊ∂à
            
            self._state = .cancelled
            print("üö´ ‰ªªÂä°ÂèñÊ∂à: \(self.taskId.uuidString.prefix(8))")
        }
    }
    
    var isCompleted: Bool {
        if case .completed = state {
            return true
        }
        return false
    }
    
    var isFailed: Bool {
        if case .failed = state {
            return true
        }
        return false
    }
    
    var isCancelled: Bool {
        if case .cancelled = state {
            return true
        }
        return false
    }
    
    private func printTimeStatistics() {
        guard let previewTime = previewTime,
              let completeTime = completeTime else { return }
        
        let previewDuration = Int((previewTime - startTime) * 1000)
        let totalDuration = Int((completeTime - startTime) * 1000)
        
        var preprocessDuration = 0
        if let preprocessTime = preprocessTime {
            preprocessDuration = Int((preprocessTime - previewTime) * 1000)
        }
        
        let renderDuration = totalDuration - previewDuration - preprocessDuration
        
        print("üìä Êó∂Èó¥ÁªüËÆ° [\(taskId.uuidString.prefix(8))]:")
        print("  - È¢ÑËßàÁîüÊàê: \(previewDuration)ms")
        print("  - È¢ÑÂ§ÑÁêÜ: \(preprocessDuration)ms") 
        print("  - Ê∏≤Êüì‰øùÂ≠ò: \(renderDuration)ms")
        print("  - ÊÄªËÄóÊó∂: \(totalDuration)ms")
        
        // ÊÄßËÉΩËØÑÁ∫ß
        let grade = evaluatePerformance(totalDuration)
        print("  - ÊÄßËÉΩËØÑÁ∫ß: \(grade)")
    }
    
    private func evaluatePerformance(_ duration: Int) -> String {
        switch duration {
        case 0..<500:
            return "üöÄ ÊûÅÈÄü (<0.5s)"
        case 500..<1000:
            return "‚ö° Âø´ÈÄü (<1s)"
        case 1000..<2000:
            return "‚úÖ ËâØÂ•Ω (<2s)"
        case 2000..<5000:
            return "‚ö†Ô∏è ‰∏ÄËà¨ (<5s)"
        default:
            return "üêå ÈúÄË¶Å‰ºòÂåñ (>5s)"
        }
    }
}

// MARK: - PhotoTaskÊï∞ÊçÆÊ®°Âûã
class PhotoTask {
    let id: UUID
    let rawPhoto: AVCapturePhoto
    let imageData: Data
    let captureSettings: CameraCaptureSettings
    let frameSettings: FrameSettings?
    let aspectRatio: AspectRatio?
    let format: PhotoFormat
    
    var preprocessedData: Data?
    var promise: PhotoPromise?
    
    let createdAt: Date
    
    init(
        id: UUID,
        rawPhoto: AVCapturePhoto,
        imageData: Data,
        captureSettings: CameraCaptureSettings,
        frameSettings: FrameSettings?,
        aspectRatio: AspectRatio?,
        format: PhotoFormat
    ) {
        self.id = id
        self.rawPhoto = rawPhoto
        self.imageData = imageData
        self.captureSettings = captureSettings
        self.frameSettings = frameSettings
        self.aspectRatio = aspectRatio
        self.format = format
        self.createdAt = Date()
    }
}

// MARK: - PhotoTaskManager
class PhotoTaskManager {
    private var activeTasks: [UUID: PhotoTask] = [:]
    private let queue = DispatchQueue(label: "com.mccamera.taskmanager", attributes: .concurrent)
    
    func registerTask(_ task: PhotoTask, promise: PhotoPromise) {
        queue.async(flags: .barrier) { [weak self] in
            self?.activeTasks[task.id] = task
            task.promise = promise
            
            print("üìù ‰ªªÂä°Ê≥®ÂÜå: \(task.id.uuidString.prefix(8)) - Ê¥ªË∑É‰ªªÂä°Êï∞: \(self?.activeTasks.count ?? 0)")
        }
    }
    
    func removeTask(_ taskId: UUID) {
        queue.async(flags: .barrier) { [weak self] in
            self?.activeTasks.removeValue(forKey: taskId)
            print("üóëÔ∏è ‰ªªÂä°Ê∏ÖÁêÜ: \(taskId.uuidString.prefix(8)) - Ââ©‰Ωô‰ªªÂä°Êï∞: \(self?.activeTasks.count ?? 0)")
        }
    }
    
    func getTask(_ taskId: UUID) -> PhotoTask? {
        return queue.sync {
            return activeTasks[taskId]
        }
    }
    
    var activeTaskCount: Int {
        return queue.sync {
            return activeTasks.count
        }
    }
    
    func getAllActiveTasks() -> [PhotoTask] {
        return queue.sync {
            return Array(activeTasks.values)
        }
    }
}